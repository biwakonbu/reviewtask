name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    name: Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.24.7']
    steps:
    - uses: actions/checkout@v5
    
    - name: Set up Go
      uses: actions/setup-go@v6.0.0
      with:
        go-version-file: 'go.mod'
        cache: true
    
    
    - name: Download dependencies
      run: |
        echo "Downloading Go module dependencies..."
        go mod download
      shell: bash
    
    - name: Run tests
      id: test
      shell: bash
      run: |
        # Set environment variable for test mode
        export REVIEWTASK_TEST_MODE=true
        
        # Run all tests consistently across all platforms
        echo "Running tests with testmode build tag..."
        set +e
        
        # First run cmd tests with testmode tag
        go test -v -timeout=10m -tags testmode ./cmd
        CMD_EXIT_CODE=$?
        
        if [ $CMD_EXIT_CODE -ne 0 ]; then
          echo "::error::cmd package tests failed with exit code $CMD_EXIT_CODE"
          exit $CMD_EXIT_CODE
        fi
        
        # Then run other package tests with coverage
        echo "Running other package tests..."
        NON_CMD_PACKAGES=$(go list ./... | grep -v '/cmd$')
        go test -v -timeout=15m -coverprofile=coverage-${{ matrix.os }}.out $NON_CMD_PACKAGES
        TEST_EXIT_CODE=$?
        
        set -e
        
        # If tests failed, provide detailed debugging information
        if [ $TEST_EXIT_CODE -ne 0 ]; then
          echo "::error::Tests failed with exit code $TEST_EXIT_CODE"
          echo "::group::Failed Test Summary"
          echo "Exit code: $TEST_EXIT_CODE"
          echo "Working directory: $(pwd)"
          echo "Go version: $(go version)"
          echo "Environment variables:"
          env | grep -E "^(GO|CI|GITHUB_)" | sort
          echo "Non-cmd packages tested: $NON_CMD_PACKAGES"
          echo "::endgroup::"
          
          exit $TEST_EXIT_CODE
        fi
        
        echo "All tests passed successfully!"
    
    - name: Debug test failures
      if: failure() && steps.test.outcome == 'failure'
      shell: bash
      run: |
        echo "::group::Detailed Test Failure Analysis"
        echo "Analyzing test failures for debugging..."
        
        # Run tests again with JSON output for structured analysis
        echo "Re-running failed tests with JSON output..."
        set +e
        go test -json ./... 2>&1 | tee test-output.json | jq -r 'select(.Action == "fail" or .Test != null and .Output != null) | "\(.Time // "") \(.Action // "") \(.Package // "") \(.Test // "") \(.Output // "")"' || true
        set -e
        
        # Look for specific error patterns
        echo "::endgroup::"
        
        echo "::group::Common Error Patterns"
        if [ -f test-output.json ]; then
          echo "Race conditions:"
          grep -i "race" test-output.json || echo "No race conditions detected"
          
          echo -e "\nPanics:"
          grep -i "panic" test-output.json || echo "No panics detected"
          
          echo -e "\nTimeout errors:"
          grep -i "timeout" test-output.json || echo "No timeout errors detected"
          
          echo -e "\nPermission errors:"
          grep -i "permission" test-output.json || echo "No permission errors detected"
        fi
        echo "::endgroup::"

    - name: Upload test artifacts on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-failure-logs-${{ matrix.os }}-${{ matrix.go-version }}
        path: |
          test-output.json
          coverage-*.out
        retention-days: 7

    - name: Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest' && matrix.go-version == '1.24.7'
      uses: codecov/codecov-action@v5
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        files: ./coverage-${{ matrix.os }}.out
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  lint:
    name: Lint
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.24.7'

    - name: Verify go.mod
      run: |
        go mod verify

    - name: golangci-lint
      uses: golangci/golangci-lint-action@v8
      with:
        version: v1.61
        args: --timeout=5m

  format:
    name: Format Check
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Set up Go
      uses: actions/setup-go@v6.0.0
      with:
        go-version-file: 'go.mod'
    
    - name: Verify go.mod
      run: |
        go mod verify

    - name: Check formatting
      run: |
        echo "Checking code formatting..."
        UNFORMATTED_FILES=$(gofmt -s -l .)
        if [ -n "$UNFORMATTED_FILES" ]; then
          echo "::error::Code formatting issues detected"
          echo "::group::Files requiring formatting"
          echo "The following files are not formatted correctly:"
          echo "$UNFORMATTED_FILES"
          echo "::endgroup::"
          
          echo "::group::Formatting differences"
          for file in $UNFORMATTED_FILES; do
            echo "=== $file ==="
            gofmt -s -d "$file"
          done
          echo "::endgroup::"
          
          echo "To fix formatting issues, run: gofmt -s -w ."
          exit 1
        fi
        echo "All files are properly formatted!"

  vet:
    name: Go Vet
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v5
    
    - name: Set up Go
      uses: actions/setup-go@v6.0.0
      with:
        go-version-file: 'go.mod'
    
    - name: Verify go.mod
      run: |
        go mod verify

    - name: Run go vet
      run: |
        echo "Running go vet..."
        set +e
        go vet ./... 2>&1 | tee vet.log
        VET_EXIT_CODE=$?
        set -e
        
        if [ $VET_EXIT_CODE -ne 0 ]; then
          echo "::error::go vet found issues"
          echo "::group::Go Vet Issues"
          cat vet.log
          echo "::endgroup::"
          
          echo "::group::Common go vet issues"
          echo "1. Printf format errors: Check format strings match arguments"
          echo "2. Unreachable code: Remove code after return/panic statements"
          echo "3. Struct tag issues: Ensure struct tags are properly formatted"
          echo "4. Copy lock issues: Don't copy types containing sync.Mutex"
          echo "::endgroup::"
          exit $VET_EXIT_CODE
        fi
        echo "go vet passed successfully!"

  # security:
  #   name: Security Scan
  #   runs-on: ubuntu-latest
  #   
  #   steps:
  #   - uses: actions/checkout@v5
  #   
  #   - name: Set up Go
  #     uses: actions/setup-go@v4
  #     with:
  #       go-version: '1.22'
  #   
  #   - name: Install and run Gosec
  #     run: |
  #       go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
  #       gosec ./...

  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        
    steps:
    - uses: actions/checkout@v5
    
    - name: Set up Go
      uses: actions/setup-go@v6.0.0
      with:
        go-version-file: 'go.mod'
    
    - name: Verify go.mod
      run: |
        go mod verify

    - name: Build binary
      id: build
      shell: bash
      run: |
        echo "Building binary..."
        set +e
        go build -v . 2>&1 | tee build.log
        BUILD_EXIT_CODE=$?
        set -e
        
        if [ $BUILD_EXIT_CODE -ne 0 ]; then
          echo "::error::Build failed with exit code $BUILD_EXIT_CODE"
          echo "::group::Build Error Details"
          echo "Exit code: $BUILD_EXIT_CODE"
          echo "Working directory: $(pwd)"
          echo "Go version: $(go version)"
          echo "Build output:"
          cat build.log
          echo "::endgroup::"
          exit $BUILD_EXIT_CODE
        fi
        
        echo "Build completed successfully!"
    
    - name: Test binary execution
      shell: bash
      run: |
        echo "Testing binary execution..."
        if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
          ./reviewtask.exe --help || {
            echo "::error::Failed to execute binary on Windows"
            echo "Binary info:"
            ls -la reviewtask.exe || true
            file reviewtask.exe || true
            exit 1
          }
        else
          ./reviewtask --help || {
            echo "::error::Failed to execute binary on ${{ matrix.os }}"
            echo "Binary info:"
            ls -la reviewtask || true
            file reviewtask || true
            exit 1
          }
        fi
        echo "Binary execution test passed!"
