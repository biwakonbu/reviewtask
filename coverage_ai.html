
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ai: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">reviewtask/internal/ai/analyzer.go (49.3%)</option>
				
				<option value="file1">reviewtask/internal/ai/claude_client.go (68.0%)</option>
				
				<option value="file2">reviewtask/internal/ai/comment_chunker.go (82.4%)</option>
				
				<option value="file3">reviewtask/internal/ai/content_summarizer.go (92.2%)</option>
				
				<option value="file4">reviewtask/internal/ai/enhanced_json_recovery.go (72.3%)</option>
				
				<option value="file5">reviewtask/internal/ai/error_tracking.go (79.2%)</option>
				
				<option value="file6">reviewtask/internal/ai/errors.go (50.0%)</option>
				
				<option value="file7">reviewtask/internal/ai/incremental.go (73.9%)</option>
				
				<option value="file8">reviewtask/internal/ai/json_recovery.go (72.4%)</option>
				
				<option value="file9">reviewtask/internal/ai/mock_claude_client.go (74.0%)</option>
				
				<option value="file10">reviewtask/internal/ai/prompt_size.go (90.6%)</option>
				
				<option value="file11">reviewtask/internal/ai/response_monitor.go (88.1%)</option>
				
				<option value="file12">reviewtask/internal/ai/retry_strategy.go (89.5%)</option>
				
				<option value="file13">reviewtask/internal/ai/statistics.go (0.0%)</option>
				
				<option value="file14">reviewtask/internal/ai/stream_processor.go (96.9%)</option>
				
				<option value="file15">reviewtask/internal/ai/task_deduplicator.go (28.8%)</option>
				
				<option value="file16">reviewtask/internal/ai/utils.go (50.0%)</option>
				
				<option value="file17">reviewtask/internal/ai/validator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ai

import (
        "context"
        "crypto/md5"
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "strings"
        "sync"
        "time"

        "reviewtask/internal/config"
        "reviewtask/internal/github"
        "reviewtask/internal/storage"

        "github.com/google/uuid"
)

type Analyzer struct {
        config             *config.Config
        validationFeedback []ValidationIssue
        claudeClient       ClaudeClient
        promptSizeTracker  *PromptSizeTracker
        responseMonitor    *ResponseMonitor
        errorTracker       *ErrorTracker
}

func NewAnalyzer(cfg *config.Config) *Analyzer <span class="cov8" title="1">{
        // Default to real Claude client
        client, err := NewRealClaudeClient()
        if err != nil </span><span class="cov8" title="1">{
                // If Claude is not available, return analyzer without client
                // This allows tests to inject their own mock
                return &amp;Analyzer{
                        config:          cfg,
                        responseMonitor: NewResponseMonitor(cfg.AISettings.VerboseMode),
                        errorTracker:    NewErrorTracker(cfg.AISettings.ErrorTrackingEnabled, cfg.AISettings.VerboseMode, ".pr-review"),
                }
        }</span>
        <span class="cov0" title="0">return &amp;Analyzer{
                config:          cfg,
                claudeClient:    client,
                responseMonitor: NewResponseMonitor(cfg.AISettings.VerboseMode),
                errorTracker:    NewErrorTracker(cfg.AISettings.ErrorTrackingEnabled, cfg.AISettings.VerboseMode, ".pr-review"),
        }</span>
}

// NewAnalyzerWithClient creates an analyzer with a specific Claude client (for testing)
func NewAnalyzerWithClient(cfg *config.Config, client ClaudeClient) *Analyzer <span class="cov8" title="1">{
        return &amp;Analyzer{
                config:          cfg,
                claudeClient:    client,
                responseMonitor: NewResponseMonitor(cfg.AISettings.VerboseMode),
                errorTracker:    NewErrorTracker(cfg.AISettings.ErrorTrackingEnabled, cfg.AISettings.VerboseMode, ".pr-review"),
        }
}</span>

type TaskRequest struct {
        Description     string `json:"description"` // AI-generated task description (user language)
        OriginText      string `json:"origin_text"` // Original review comment text
        Priority        string `json:"priority"`
        SourceReviewID  int64  `json:"source_review_id"`
        SourceCommentID int64  `json:"source_comment_id"` // Required: specific comment ID
        File            string `json:"file"`
        Line            int    `json:"line"`
        Status          string `json:"status"`
        TaskIndex       int    `json:"task_index"` // New: index within comment (0, 1, 2...)
}

type ValidationResult struct {
        IsValid bool              `json:"is_valid"`
        Score   float64           `json:"score"` // 0.0-1.0 quality score
        Issues  []ValidationIssue `json:"issues"`
        Tasks   []TaskRequest     `json:"tasks"`
}

type ValidationIssue struct {
        Type        string `json:"type"`        // "format", "content", "missing", "incorrect"
        TaskIndex   int    `json:"task_index"`  // -1 for general issues
        Field       string `json:"field"`       // specific field with issue
        Description string `json:"description"` // human-readable issue description
        Severity    string `json:"severity"`    // "critical", "major", "minor"
}

type TaskValidator struct {
        config     *config.Config
        maxRetries int
}

func NewTaskValidator(cfg *config.Config) *TaskValidator <span class="cov8" title="1">{
        return &amp;TaskValidator{
                config:     cfg,
                maxRetries: cfg.AISettings.MaxRetries,
        }
}</span>

func (a *Analyzer) GenerateTasks(reviews []github.Review) ([]storage.Task, error) <span class="cov8" title="1">{
        // Clear validation feedback to ensure clean state for each PR analysis
        a.clearValidationFeedback()

        if len(reviews) == 0 </span><span class="cov0" title="0">{
                return []storage.Task{}, nil
        }</span>

        // Extract all comments from all reviews, filtering out resolved comments
        <span class="cov8" title="1">var allComments []CommentContext
        resolvedCommentCount := 0

        for _, review := range reviews </span><span class="cov8" title="1">{
                // Process review body as a comment if it exists and contains content
                if review.Body != "" </span><span class="cov8" title="1">{
                        // Create a pseudo-comment from the review body
                        reviewBodyComment := github.Comment{
                                ID:        review.ID, // Use review ID
                                File:      "",        // Review body is not file-specific
                                Line:      0,         // Review body is not line-specific
                                Body:      review.Body,
                                Author:    review.Reviewer,
                                CreatedAt: review.SubmittedAt,
                        }

                        // Skip if this review body comment has been marked as resolved
                        if !a.isCommentResolved(reviewBodyComment) </span><span class="cov8" title="1">{
                                allComments = append(allComments, CommentContext{
                                        Comment:      reviewBodyComment,
                                        SourceReview: review,
                                })
                        }</span> else<span class="cov0" title="0"> {
                                resolvedCommentCount++
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("✅ Skipping resolved review body %d: %.50s...\n", review.ID, review.Body)
                                }</span>
                        }
                }

                // Process individual inline comments
                <span class="cov8" title="1">for _, comment := range review.Comments </span><span class="cov8" title="1">{
                        // Skip comments that have been marked as addressed/resolved
                        if a.isCommentResolved(comment) </span><span class="cov0" title="0">{
                                resolvedCommentCount++
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("✅ Skipping resolved comment %d: %.50s...\n", comment.ID, comment.Body)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov8" title="1">allComments = append(allComments, CommentContext{
                                Comment:      comment,
                                SourceReview: review,
                        })</span>
                }
        }

        <span class="cov8" title="1">if resolvedCommentCount &gt; 0 </span><span class="cov0" title="0">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("📝 Filtered out %d resolved comments\n", resolvedCommentCount)
                }</span>
        }

        <span class="cov8" title="1">if len(allComments) == 0 </span><span class="cov0" title="0">{
                return []storage.Task{}, nil
        }</span>

        // Check if validation is enabled in config
        <span class="cov8" title="1">if a.config.AISettings.ValidationEnabled != nil &amp;&amp; *a.config.AISettings.ValidationEnabled </span><span class="cov8" title="1">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  🐛 Using validation-enabled path with parallel processing\n")
                }</span>
                // Use parallel processing for validation mode to handle large PRs
                <span class="cov8" title="1">return a.generateTasksParallelWithValidation(allComments)</span>
        }

        <span class="cov8" title="1">return a.generateTasksParallel(allComments)</span>
}

// GenerateTasksWithCache generates tasks with MD5-based change detection using existing data
func (a *Analyzer) GenerateTasksWithCache(reviews []github.Review, prNumber int, storageManager *storage.Manager) ([]storage.Task, error) <span class="cov0" title="0">{
        // Clear validation feedback to ensure clean state for each PR analysis
        a.clearValidationFeedback()

        if len(reviews) == 0 </span><span class="cov0" title="0">{
                return []storage.Task{}, nil
        }</span>

        // Extract all comments and create content hash map
        <span class="cov0" title="0">var allComments []github.Comment
        var allCommentsCtx []CommentContext
        commentHashMap := make(map[int64]string)
        resolvedCommentCount := 0

        for _, review := range reviews </span><span class="cov0" title="0">{
                // Process review body as a comment if it exists and contains content
                if review.Body != "" </span><span class="cov0" title="0">{
                        // Create a pseudo-comment from the review body
                        reviewBodyComment := github.Comment{
                                ID:        review.ID, // Use review ID
                                File:      "",        // Review body is not file-specific
                                Line:      0,         // Review body is not line-specific
                                Body:      review.Body,
                                Author:    review.Reviewer,
                                CreatedAt: review.SubmittedAt,
                        }

                        // Skip if this review body comment has been marked as resolved
                        if !a.isCommentResolved(reviewBodyComment) </span><span class="cov0" title="0">{
                                allComments = append(allComments, reviewBodyComment)
                                allCommentsCtx = append(allCommentsCtx, CommentContext{
                                        Comment:      reviewBodyComment,
                                        SourceReview: review,
                                })
                                // Calculate MD5 hash of review body
                                commentHashMap[review.ID] = a.calculateCommentHash(reviewBodyComment)
                        }</span> else<span class="cov0" title="0"> {
                                resolvedCommentCount++
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("✅ Skipping resolved review body %d: %.50s...\n", review.ID, review.Body)
                                }</span>
                        }
                }

                // Process individual inline comments
                <span class="cov0" title="0">for _, comment := range review.Comments </span><span class="cov0" title="0">{
                        // Skip comments that have been marked as addressed/resolved
                        if a.isCommentResolved(comment) </span><span class="cov0" title="0">{
                                resolvedCommentCount++
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("✅ Skipping resolved comment %d: %.50s...\n", comment.ID, comment.Body)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov0" title="0">allComments = append(allComments, comment)
                        allCommentsCtx = append(allCommentsCtx, CommentContext{
                                Comment:      comment,
                                SourceReview: review,
                        })
                        // Calculate MD5 hash of entire comment thread (main comment + all replies)
                        commentHashMap[comment.ID] = a.calculateCommentHash(comment)</span>
                }
        }

        <span class="cov0" title="0">if resolvedCommentCount &gt; 0 </span><span class="cov0" title="0">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("📝 Filtered out %d resolved comments\n", resolvedCommentCount)
                }</span>
        }

        <span class="cov0" title="0">if len(allComments) == 0 </span><span class="cov0" title="0">{
                return []storage.Task{}, nil
        }</span>

        // Load existing tasks to compare hashes
        <span class="cov0" title="0">existingTasks, err := storageManager.GetTasksByPR(prNumber)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load existing tasks: %w", err)
        }</span>

        // Create map of existing task hashes by comment ID
        <span class="cov0" title="0">existingHashMap := make(map[int64]string)
        existingTasksByComment := make(map[int64][]storage.Task)
        for _, task := range existingTasks </span><span class="cov0" title="0">{
                if task.CommentHash != "" </span><span class="cov0" title="0">{
                        existingHashMap[task.SourceCommentID] = task.CommentHash
                }</span>
                <span class="cov0" title="0">existingTasksByComment[task.SourceCommentID] = append(existingTasksByComment[task.SourceCommentID], task)</span>
        }

        // Detect changes by comparing current hashes with existing hashes
        <span class="cov0" title="0">var changedCommentsCtx []CommentContext
        var unchangedTasks []storage.Task

        for _, commentCtx := range allCommentsCtx </span><span class="cov0" title="0">{
                comment := commentCtx.Comment
                currentHash := commentHashMap[comment.ID]
                existingHash, hasExistingTasks := existingHashMap[comment.ID]

                if !hasExistingTasks || existingHash != currentHash </span><span class="cov0" title="0">{
                        // Comment is new or has changed - needs reprocessing
                        changedCommentsCtx = append(changedCommentsCtx, commentCtx)
                }</span> else<span class="cov0" title="0"> {
                        // Comment is unchanged - keep existing tasks
                        unchangedTasks = append(unchangedTasks, existingTasksByComment[comment.ID]...)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("📊 Change analysis: %d unchanged, %d changed/new comments\n",
                len(allCommentsCtx)-len(changedCommentsCtx), len(changedCommentsCtx))

        var newTasks []storage.Task
        if len(changedCommentsCtx) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("🤖 Generating tasks for %d changed/new comments...\n", len(changedCommentsCtx))

                // Generate tasks only for changed comments
                if a.config.AISettings.ValidationEnabled != nil &amp;&amp; *a.config.AISettings.ValidationEnabled </span><span class="cov0" title="0">{
                        newTasks, err = a.generateTasksParallelWithValidation(changedCommentsCtx)
                }</span> else<span class="cov0" title="0"> {
                        newTasks, err = a.generateTasksParallel(changedCommentsCtx)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate tasks: %w", err)
                }</span>

                // Set comment hash for new tasks
                <span class="cov0" title="0">for i := range newTasks </span><span class="cov0" title="0">{
                        newTasks[i].CommentHash = commentHashMap[newTasks[i].SourceCommentID]
                }</span>
        } else<span class="cov0" title="0"> {
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("✅ All comments are unchanged - no AI processing needed\n")
                }</span>
        }

        // Combine unchanged tasks with newly generated tasks
        <span class="cov0" title="0">allTasks := append(unchangedTasks, newTasks...)

        fmt.Printf("📋 Task summary: %d unchanged + %d newly generated = %d total\n",
                len(unchangedTasks), len(newTasks), len(allTasks))

        return allTasks, nil</span>
}

// calculateCommentHash generates MD5 hash of entire comment thread including replies
func (a *Analyzer) calculateCommentHash(comment github.Comment) string <span class="cov8" title="1">{
        content := comment.Body
        for _, reply := range comment.Replies </span><span class="cov0" title="0">{
                content += reply.Body
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%x", md5.Sum([]byte(content)))</span>
}

type CommentContext struct {
        Comment      github.Comment
        SourceReview github.Review
}

func (a *Analyzer) GenerateTasksWithValidation(reviews []github.Review) ([]storage.Task, error) <span class="cov0" title="0">{
        validator := NewTaskValidator(a.config)
        var bestResult *ValidationResult
        var bestTasks []TaskRequest
        maxScore := 0.0

        for attempt := 1; attempt &lt;= validator.maxRetries; attempt++ </span><span class="cov0" title="0">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("🔄 Task generation attempt %d/%d...\n", attempt, validator.maxRetries)
                }</span>

                // Generate tasks
                <span class="cov0" title="0">tasks, err := a.callClaudeCodeWithRetry(reviews, attempt)
                if err != nil </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  ❌ Generation failed: %v\n", err)
                        }</span>
                        // If it's a prompt size error, no point in retrying
                        <span class="cov0" title="0">if strings.Contains(err.Error(), "prompt size") &amp;&amp; strings.Contains(err.Error(), "exceeds maximum limit") </span><span class="cov0" title="0">{
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("  ⚠️  Prompt size limit exceeded - stopping retries (use parallel processing instead)\n")
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Stage 1: Format validation
                <span class="cov0" title="0">formatResult, err := validator.validateFormat(tasks)
                if err != nil </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  ❌ Format validation failed: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if !formatResult.IsValid </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  ⚠️  Format issues found (score: %.2f)\n", formatResult.Score)
                        }</span>
                        <span class="cov0" title="0">if formatResult.Score &gt; maxScore </span><span class="cov0" title="0">{
                                bestResult = formatResult
                                bestTasks = formatResult.Tasks
                                maxScore = formatResult.Score
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Stage 2: Content validation
                <span class="cov0" title="0">contentResult, err := validator.validateContent(formatResult.Tasks, reviews)
                if err != nil </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  ❌ Content validation failed: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("  📊 Validation score: %.2f\n", contentResult.Score)

                // Track best result
                if contentResult.Score &gt; maxScore </span><span class="cov0" title="0">{
                        bestResult = contentResult
                        bestTasks = formatResult.Tasks
                        maxScore = contentResult.Score
                }</span>

                // Check if validation passed
                <span class="cov0" title="0">if contentResult.IsValid &amp;&amp; contentResult.Score &gt;= a.config.AISettings.QualityThreshold </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  ✅ Validation passed!\n")
                        }</span>
                        <span class="cov0" title="0">return a.convertToStorageTasks(formatResult.Tasks), nil</span>
                }

                // If not valid, add validation feedback for next iteration
                <span class="cov0" title="0">if attempt &lt; validator.maxRetries </span><span class="cov0" title="0">{
                        fmt.Printf("  🔧 Preparing improved prompt for next attempt...\n")
                        a.addValidationFeedback(contentResult.Issues)
                }</span>
        }

        // Use best result if no perfect validation achieved
        <span class="cov0" title="0">if bestResult != nil &amp;&amp; len(bestTasks) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Using best result (score: %.2f) after %d attempts\n", maxScore, validator.maxRetries)
                return a.convertToStorageTasks(bestTasks), nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to generate valid tasks after %d attempts", validator.maxRetries)</span>
}

// generateTasksLegacy is kept for historical reference; not used.
// Leaving the function commented to avoid unused warnings.
// func (a *Analyzer) generateTasksLegacy(reviews []github.Review) ([]storage.Task, error) {
//     prompt := a.buildAnalysisPrompt(reviews)
//     tasks, err := a.callClaudeCode(prompt)
//     if err != nil {
//         return nil, fmt.Errorf("failed to call Claude Code: %w", err)
//     }
//     return a.convertToStorageTasks(tasks), nil
// }

func (a *Analyzer) buildAnalysisPrompt(reviews []github.Review) string <span class="cov8" title="1">{
        // Initialize prompt size tracker
        a.promptSizeTracker = NewPromptSizeTracker()

        var languageInstruction string
        if a.config.AISettings.UserLanguage != "" </span><span class="cov8" title="1">{
                languageInstruction = fmt.Sprintf("IMPORTANT: Generate task descriptions in %s language.\n", a.config.AISettings.UserLanguage)
        }</span>
        <span class="cov8" title="1">a.promptSizeTracker.TrackLanguagePrompt(languageInstruction)

        priorityPrompt := a.config.GetPriorityPrompt()
        a.promptSizeTracker.TrackPriorityPrompt(priorityPrompt)

        // Add nitpick handling instructions
        nitpickInstruction := a.buildNitpickInstruction()
        a.promptSizeTracker.TrackNitpickPrompt(nitpickInstruction)

        // Build review data
        var reviewsData strings.Builder
        reviewsData.WriteString("PR Reviews to analyze:\n\n")

        for i, review := range reviews </span><span class="cov8" title="1">{
                reviewsData.WriteString(fmt.Sprintf("Review %d (ID: %d):\n", i+1, review.ID))
                reviewsData.WriteString(fmt.Sprintf("Reviewer: %s\n", review.Reviewer))
                reviewsData.WriteString(fmt.Sprintf("State: %s\n", review.State))

                if review.Body != "" </span><span class="cov8" title="1">{
                        reviewsData.WriteString(fmt.Sprintf("Review Body: %s\n", review.Body))
                }</span>

                <span class="cov8" title="1">if len(review.Comments) &gt; 0 </span><span class="cov8" title="1">{
                        reviewsData.WriteString("Comments:\n")
                        for _, comment := range review.Comments </span><span class="cov8" title="1">{
                                reviewsData.WriteString(fmt.Sprintf("  Comment ID: %d\n", comment.ID))
                                reviewsData.WriteString(fmt.Sprintf("  File: %s:%d\n", comment.File, comment.Line))
                                reviewsData.WriteString(fmt.Sprintf("  Author: %s\n", comment.Author))
                                reviewsData.WriteString(fmt.Sprintf("  Text: %s\n", comment.Body))

                                if len(comment.Replies) &gt; 0 </span><span class="cov0" title="0">{
                                        reviewsData.WriteString("  Replies:\n")
                                        for _, reply := range comment.Replies </span><span class="cov0" title="0">{
                                                reviewsData.WriteString(fmt.Sprintf("    - %s: %s\n", reply.Author, reply.Body))
                                        }</span>
                                }
                                <span class="cov8" title="1">reviewsData.WriteString("\n")</span>
                        }
                }
                <span class="cov8" title="1">reviewsData.WriteString("\n")</span>
        }

        // Track review data
        <span class="cov8" title="1">reviewsDataStr := reviewsData.String()
        a.promptSizeTracker.TrackReviewsData(reviewsDataStr, reviews)

        // Build system prompt
        systemPrompt := `You are an AI assistant helping to analyze GitHub PR reviews and generate actionable tasks.

CRITICAL: Return response as JSON array with this EXACT format:
[
  {
    "description": "Actionable task description in specified language",
    "origin_text": "Original review comment text (preserve exactly)",
    "priority": "critical|high|medium|low",
    "source_review_id": 12345,
    "source_comment_id": 67890,
    "file": "path/to/file.go",
    "line": 42,
    "task_index": 0
  }
]

Requirements:
1. PRESERVE original comment text in 'origin_text' field exactly as written
2. Generate clear, actionable 'description' in the specified user language
3. Create appropriate number of tasks based on the comment's content
4. Each distinct actionable item should be a separate task
5. Assign task_index starting from 0 for multiple tasks
6. Only create tasks for comments requiring developer action
7. Consider comment chains - don't create tasks for resolved issues

Task Generation Guidelines:
- Create separate tasks for logically distinct actions
- If a comment mentions multiple unrelated issues, create separate tasks
- Ensure each task is self-contained and actionable
- Don't artificially combine unrelated items
- AI deduplication will handle any redundancy later`
        a.promptSizeTracker.TrackSystemPrompt(systemPrompt)

        prompt := fmt.Sprintf("%s\n\n%s\n%s\n%s\n\n%s", systemPrompt, languageInstruction, priorityPrompt, nitpickInstruction, reviewsDataStr)

        return prompt</span>
}

func (a *Analyzer) callClaudeCode(prompt string) ([]TaskRequest, error) <span class="cov8" title="1">{
        return a.callClaudeCodeWithRetryStrategy(prompt, 0)
}</span>

// callClaudeCodeWithRetryStrategy executes Claude API call with intelligent retry logic
func (a *Analyzer) callClaudeCodeWithRetryStrategy(originalPrompt string, attemptNumber int) ([]TaskRequest, error) <span class="cov8" title="1">{
        prompt := originalPrompt
        startTime := time.Now()
        sessionID := uuid.New().String()

        // Initialize retry strategy if this is the first attempt
        var retryStrategy *RetryStrategy
        if attemptNumber == 0 &amp;&amp; a.config.AISettings.EnableJSONRecovery </span><span class="cov8" title="1">{
                retryStrategy = NewRetryStrategy(a.config.AISettings.VerboseMode)
        }</span>

        // Check for very large prompts that might exceed system limits
        <span class="cov8" title="1">const maxPromptSize = 32 * 1024 // 32KB limit for safety
        if len(prompt) &gt; maxPromptSize </span><span class="cov8" title="1">{
                // Generate detailed error message if tracker is available
                if a.promptSizeTracker != nil &amp;&amp; a.promptSizeTracker.IsExceeded() </span><span class="cov8" title="1">{
                        if a.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("%s", a.promptSizeTracker.GenerateErrorMessage())
                        }</span> else<span class="cov8" title="1"> {
                                // In non-debug mode, show simplified error with key info
                                largestComponent, largestSize := a.promptSizeTracker.GetLargestComponent()
                                return nil, fmt.Errorf("prompt size (%d bytes) exceeds maximum limit (%d bytes). %s is too large (%d bytes). Use --verbose for detailed breakdown",
                                        len(prompt), maxPromptSize, largestComponent, largestSize)
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("prompt size (%d bytes) exceeds maximum limit (%d bytes). Please shorten or chunk the prompt content", len(prompt), maxPromptSize)</span>
        }

        // Use injected client if available, otherwise create a real one
        <span class="cov8" title="1">client := a.claudeClient
        if client == nil </span><span class="cov0" title="0">{
                var err error
                client, err = NewRealClaudeClient()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewClaudeAPIError("client initialization failed", err)
                }</span>
        }

        // Debug information if enabled
        <span class="cov8" title="1">if a.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                fmt.Printf("  🐛 Prompt size: %d characters (attempt %d)\n", len(prompt), attemptNumber+1)
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        output, err := client.Execute(ctx, prompt, "json")

        // Track response size for retry strategy analysis
        responseSize := len(output)

        if err != nil </span><span class="cov8" title="1">{
                // Check if we should retry with enhanced strategy
                if retryStrategy != nil </span><span class="cov0" title="0">{
                        retryAttempt, shouldRetry := retryStrategy.ShouldRetry(attemptNumber, err, len(prompt), responseSize)
                        if shouldRetry </span><span class="cov0" title="0">{
                                // Execute retry delay
                                retryStrategy.ExecuteDelay(retryAttempt)

                                // Adjust prompt if needed
                                adjustedPrompt := retryStrategy.AdjustPromptForRetry(originalPrompt, retryAttempt)
                                if adjustedPrompt != originalPrompt </span><span class="cov0" title="0">{
                                        retryAttempt.AdjustedPrompt = true
                                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                                fmt.Printf("  🔧 Adjusted prompt size: %d -&gt; %d bytes\n", len(originalPrompt), len(adjustedPrompt))
                                        }</span>
                                }

                                // Recursive retry with adjusted prompt
                                <span class="cov0" title="0">return a.callClaudeCodeWithRetryStrategy(adjustedPrompt, attemptNumber+1)</span>
                        }
                }
                // Record API failure event for monitoring
                <span class="cov8" title="1">if a.responseMonitor != nil </span><span class="cov8" title="1">{
                        processingTime := time.Since(startTime).Milliseconds()
                        event := ResponseEvent{
                                Timestamp:       time.Now(),
                                SessionID:       sessionID,
                                PromptSize:      len(prompt),
                                ResponseSize:    responseSize,
                                ProcessingTime:  processingTime,
                                Success:         false,
                                ErrorType:       "api_execution_failed",
                                RecoveryUsed:    false,
                                RetryCount:      attemptNumber,
                                TasksExtracted:  0,
                                PromptOptimized: len(prompt) &lt; len(originalPrompt),
                        }
                        _ = a.responseMonitor.RecordEvent(event)
                }</span>

                <span class="cov8" title="1">return nil, NewClaudeAPIError("execution failed", err)</span>
        }

        // Parse Claude Code CLI response wrapper
        <span class="cov8" title="1">var claudeResponse struct {
                Type    string `json:"type"`
                Subtype string `json:"subtype"`
                IsError bool   `json:"is_error"`
                Result  string `json:"result"`
        }

        if err := json.Unmarshal([]byte(output), &amp;claudeResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse claude wrapper response: %w", err)
        }</span>

        <span class="cov8" title="1">if claudeResponse.IsError </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("claude returned error: %s", claudeResponse.Result)
        }</span>

        // Extract JSON from result (may be wrapped in markdown code block or text)
        <span class="cov8" title="1">result := claudeResponse.Result
        result = strings.TrimSpace(result)

        // Debug: log first part of response if debug mode is enabled
        if a.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                preview := result
                if len(preview) &gt; 500 </span><span class="cov8" title="1">{
                        preview = preview[:500] + "..."
                }</span>
                <span class="cov8" title="1">fmt.Printf("  🐛 Claude response preview: %s\n", preview)</span>
        }

        // Enhanced JSON extraction for better CodeRabbit compatibility
        <span class="cov8" title="1">result = a.extractJSON(result)
        if result == "" </span><span class="cov0" title="0">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  🐛 Full Claude response: %s\n", claudeResponse.Result)
                }</span>
                // For CodeRabbit nitpick comments, return empty array instead of error
                <span class="cov0" title="0">if a.config.AISettings.ProcessNitpickComments &amp;&amp; a.isCodeRabbitNitpickResponse(claudeResponse.Result) </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  🔄 CodeRabbit nitpick detected with no actionable tasks - returning empty array\n")
                        }</span>
                        <span class="cov0" title="0">return []TaskRequest{}, nil</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("no valid JSON found in Claude response")</span>
        }

        // Parse the actual task array with recovery mechanism
        <span class="cov8" title="1">var tasks []TaskRequest
        if err := json.Unmarshal([]byte(result), &amp;tasks); err != nil </span><span class="cov0" title="0">{
                // First attempt JSON recovery for incomplete/malformed responses
                recoverer := NewJSONRecoverer(
                        a.config.AISettings.EnableJSONRecovery,
                        a.config.AISettings.VerboseMode,
                )

                recoveryResult := recoverer.RecoverJSON(result, err)
                recoverer.LogRecoveryAttempt(recoveryResult)

                // If standard recovery failed, try enhanced recovery
                if !recoveryResult.IsRecovered || len(recoveryResult.Tasks) == 0 </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  🚀 Trying enhanced JSON recovery...\n")
                        }</span>
                        <span class="cov0" title="0">enhancedRecoverer := NewEnhancedJSONRecovery(
                                a.config.AISettings.EnableJSONRecovery,
                                a.config.AISettings.VerboseMode,
                        )
                        recoveryResult = enhancedRecoverer.RepairAndRecover(result, err)</span>
                }

                <span class="cov0" title="0">if recoveryResult.IsRecovered &amp;&amp; len(recoveryResult.Tasks) &gt; 0 </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  ✅ JSON recovery successful: %s\n", recoveryResult.Message)
                        }</span>
                        <span class="cov0" title="0">tasks = recoveryResult.Tasks

                        // Record successful recovery event for monitoring
                        if a.responseMonitor != nil </span><span class="cov0" title="0">{
                                processingTime := time.Since(startTime).Milliseconds()
                                event := ResponseEvent{
                                        Timestamp:       time.Now(),
                                        SessionID:       sessionID,
                                        PromptSize:      len(prompt),
                                        ResponseSize:    responseSize,
                                        ProcessingTime:  processingTime,
                                        Success:         true,
                                        RecoveryUsed:    true,
                                        RetryCount:      attemptNumber,
                                        TasksExtracted:  len(recoveryResult.Tasks),
                                        PromptOptimized: len(prompt) &lt; len(originalPrompt),
                                }
                                _ = a.responseMonitor.RecordEvent(event)
                        }</span>

                        <span class="cov0" title="0">return tasks, nil</span>
                } else<span class="cov0" title="0"> {
                        // JSON recovery failed, check if we should retry the entire request
                        if retryStrategy != nil &amp;&amp; attemptNumber &lt; retryStrategy.config.MaxRetries </span><span class="cov0" title="0">{
                                retryAttempt, shouldRetry := retryStrategy.ShouldRetry(attemptNumber, err, len(prompt), responseSize)
                                if shouldRetry </span><span class="cov0" title="0">{
                                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                                fmt.Printf("  🔄 JSON parsing failed, attempting full retry with strategy: %s\n", retryAttempt.Strategy)
                                        }</span>

                                        // Execute retry delay
                                        <span class="cov0" title="0">retryStrategy.ExecuteDelay(retryAttempt)

                                        // Adjust prompt if needed
                                        adjustedPrompt := retryStrategy.AdjustPromptForRetry(originalPrompt, retryAttempt)
                                        if adjustedPrompt != originalPrompt </span><span class="cov0" title="0">{
                                                retryAttempt.AdjustedPrompt = true
                                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                                        fmt.Printf("  🔧 Adjusted prompt size for retry: %d -&gt; %d bytes\n", len(originalPrompt), len(adjustedPrompt))
                                                }</span>
                                        }

                                        // Recursive retry with adjusted prompt
                                        <span class="cov0" title="0">return a.callClaudeCodeWithRetryStrategy(adjustedPrompt, attemptNumber+1)</span>
                                }
                        }

                        // Record failure event for monitoring
                        <span class="cov0" title="0">if a.responseMonitor != nil </span><span class="cov0" title="0">{
                                processingTime := time.Since(startTime).Milliseconds()
                                event := ResponseEvent{
                                        Timestamp:       time.Now(),
                                        SessionID:       sessionID,
                                        PromptSize:      len(prompt),
                                        ResponseSize:    responseSize,
                                        ProcessingTime:  processingTime,
                                        Success:         false,
                                        ErrorType:       "json_parsing_failed",
                                        RecoveryUsed:    true,
                                        RetryCount:      attemptNumber,
                                        TasksExtracted:  0,
                                        PromptOptimized: len(prompt) &lt; len(originalPrompt),
                                }
                                _ = a.responseMonitor.RecordEvent(event)
                        }</span>

                        // Recovery and retry both failed, return original error with recovery info
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to parse task array from result: %w (recovery attempted: %s)\nResult was: %s",
                                err, recoveryResult.Message, result)</span>
                }
        }

        // Record successful response event for monitoring
        <span class="cov8" title="1">if a.responseMonitor != nil </span><span class="cov8" title="1">{
                processingTime := time.Since(startTime).Milliseconds()
                event := ResponseEvent{
                        Timestamp:       time.Now(),
                        SessionID:       sessionID,
                        PromptSize:      len(prompt),
                        ResponseSize:    responseSize,
                        ProcessingTime:  processingTime,
                        Success:         true,
                        RecoveryUsed:    false, // Will be updated if recovery was used
                        RetryCount:      attemptNumber,
                        TasksExtracted:  len(tasks),
                        PromptOptimized: len(prompt) &lt; len(originalPrompt),
                }

                _ = a.responseMonitor.RecordEvent(event)
        }</span>

        <span class="cov8" title="1">return tasks, nil</span>
}

// convertToStorageTasks converts AI-generated TaskRequest objects to storage.Task objects.
//
// SPECIFICATION: UUID-based Task ID Generation
// Task IDs are generated using UUIDs (via uuid.New().String()) to ensure:
// 1. Global uniqueness guarantee - no collisions possible
// 2. Unpredictability for security - cannot be guessed
// 3. No dependency on other field values - future-proof design
// 4. Standards compliance - follows RFC 4122
//
// WARNING: DO NOT revert to comment-based ID formats like "comment-%d-task-%d".
// Such approaches are fundamentally flawed and create collision risks.
func (a *Analyzer) convertToStorageTasks(tasks []TaskRequest) []storage.Task <span class="cov8" title="1">{
        var result []storage.Task
        now := time.Now().Format("2006-01-02T15:04:05Z")

        for _, task := range tasks </span><span class="cov8" title="1">{
                // Determine initial status based on low-priority patterns
                status := a.config.TaskSettings.DefaultStatus
                if a.isLowPriorityComment(task.OriginText) </span><span class="cov8" title="1">{
                        status = a.config.TaskSettings.LowPriorityStatus
                }</span>

                // Override priority for nitpick comments if configured
                <span class="cov8" title="1">priority := task.Priority
                if a.config.AISettings.ProcessNitpickComments &amp;&amp; a.isLowPriorityComment(task.OriginText) </span><span class="cov8" title="1">{
                        priority = a.config.AISettings.NitpickPriority
                }</span>

                <span class="cov8" title="1">storageTask := storage.Task{
                        // UUID-based ID generation ensures global uniqueness and security
                        ID:              uuid.New().String(),
                        Description:     task.Description,
                        OriginText:      task.OriginText,
                        Priority:        priority,
                        SourceReviewID:  task.SourceReviewID,
                        SourceCommentID: task.SourceCommentID,
                        TaskIndex:       task.TaskIndex,
                        File:            task.File,
                        Line:            task.Line,
                        Status:          status,
                        CreatedAt:       now,
                        UpdatedAt:       now,
                }
                result = append(result, storageTask)</span>
        }

        <span class="cov8" title="1">return result</span>
}

// IsLowPriorityComment checks if a comment body contains any low-priority patterns (public for testing)
func (a *Analyzer) IsLowPriorityComment(commentBody string) bool <span class="cov0" title="0">{
        return a.isLowPriorityComment(commentBody)
}</span>

// isLowPriorityComment checks if a comment body contains any low-priority patterns
func (a *Analyzer) isLowPriorityComment(commentBody string) bool <span class="cov8" title="1">{
        if len(a.config.TaskSettings.LowPriorityPatterns) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Convert to lowercase for case-insensitive matching
        <span class="cov8" title="1">lowerBody := strings.ToLower(commentBody)

        // Check traditional patterns first
        for _, pattern := range a.config.TaskSettings.LowPriorityPatterns </span><span class="cov8" title="1">{
                // Check if the comment starts with the pattern (case-insensitive)
                if strings.HasPrefix(lowerBody, strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return true
                }</span>
                // Also check if the pattern appears after newline (for multi-line comments)
                <span class="cov8" title="1">if strings.Contains(lowerBody, "\n"+strings.ToLower(pattern)) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check for CodeRabbit structured patterns
        <span class="cov8" title="1">if a.isCodeRabbitNitpickComment(lowerBody) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// isCodeRabbitNitpickComment detects CodeRabbit nitpick comments in structured format
func (a *Analyzer) isCodeRabbitNitpickComment(lowerBody string) bool <span class="cov8" title="1">{
        // CodeRabbit patterns to detect
        coderabbitPatterns := []string{
                "🧹 nitpick",
                "nitpick comments",
                "nitpick comment",
                "&lt;summary&gt;🧹 nitpick",
                "&lt;summary&gt;nitpick",
                "nitpick comments (",
                "nitpick comment (",
        }

        for _, pattern := range coderabbitPatterns </span><span class="cov8" title="1">{
                if strings.Contains(lowerBody, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check for structured HTML content that might contain nitpicks
        <span class="cov8" title="1">if a.hasStructuredNitpickContent(lowerBody) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// hasStructuredNitpickContent checks for structured HTML content with nitpick indicators
func (a *Analyzer) hasStructuredNitpickContent(lowerBody string) bool <span class="cov8" title="1">{
        // Look for &lt;details&gt; blocks with summary containing nitpick-related content
        if strings.Contains(lowerBody, "&lt;details&gt;") &amp;&amp; strings.Contains(lowerBody, "&lt;summary&gt;") </span><span class="cov8" title="1">{
                // Extract content between &lt;summary&gt; tags
                summaryStart := strings.Index(lowerBody, "&lt;summary&gt;")
                if summaryStart == -1 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">summaryEnd := strings.Index(lowerBody[summaryStart:], "&lt;/summary&gt;")
                if summaryEnd == -1 </span><span class="cov0" title="0">{
                        // Look for closing pattern without explicit tag
                        summaryEnd = strings.Index(lowerBody[summaryStart:], "&gt;")
                        if summaryEnd == -1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                // Validate that summaryStart+summaryEnd doesn't exceed bounds before applying buffer
                <span class="cov8" title="1">baseEndPos := summaryStart + summaryEnd
                if baseEndPos &gt; len(lowerBody) </span><span class="cov0" title="0">{
                        baseEndPos = len(lowerBody)
                }</span>

                // Apply buffer with bounds checking
                <span class="cov8" title="1">endPos := baseEndPos + 20
                if endPos &gt; len(lowerBody) </span><span class="cov0" title="0">{
                        endPos = len(lowerBody)
                }</span>
                <span class="cov8" title="1">summaryContent := lowerBody[summaryStart:endPos]

                // Check if summary contains nitpick indicators
                nitpickIndicators := []string{
                        "nitpick",
                        "nit",
                        "🧹",
                        "minor",
                        "style",
                        "suggestion",
                }

                for _, indicator := range nitpickIndicators </span><span class="cov8" title="1">{
                        if strings.Contains(summaryContent, indicator) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

func (a *Analyzer) callClaudeCodeWithRetry(reviews []github.Review, attempt int) ([]TaskRequest, error) <span class="cov0" title="0">{
        var prompt string
        if attempt == 1 </span><span class="cov0" title="0">{
                prompt = a.buildAnalysisPrompt(reviews)
        }</span> else<span class="cov0" title="0"> {
                prompt = a.buildAnalysisPromptWithFeedback(reviews)
        }</span>

        <span class="cov0" title="0">return a.callClaudeCode(prompt)</span>
}

func (a *Analyzer) buildAnalysisPromptWithFeedback(reviews []github.Review) string <span class="cov0" title="0">{
        basePrompt := a.buildAnalysisPrompt(reviews)

        // Add validation feedback if available
        if len(a.validationFeedback) &gt; 0 </span><span class="cov0" title="0">{
                var feedback strings.Builder
                feedback.WriteString("\n\nIMPROVEMENT FEEDBACK from previous attempt:\n")
                feedback.WriteString("Please address these issues in your task generation:\n\n")

                for i, issue := range a.validationFeedback </span><span class="cov0" title="0">{
                        feedback.WriteString(fmt.Sprintf("%d. %s (Severity: %s)\n", i+1, issue.Description, issue.Severity))
                }</span>

                <span class="cov0" title="0">feedback.WriteString("\nEnsure your response addresses all these concerns.\n")
                basePrompt += feedback.String()</span>
        }

        <span class="cov0" title="0">return basePrompt</span>
}

func (a *Analyzer) addValidationFeedback(issues []ValidationIssue) <span class="cov0" title="0">{
        a.validationFeedback = issues
}</span>

// clearValidationFeedback clears validation feedback when starting new analysis
func (a *Analyzer) clearValidationFeedback() <span class="cov8" title="1">{
        a.validationFeedback = nil
}</span>

// processCommentsParallel handles common parallel processing logic
func (a *Analyzer) processCommentsParallel(comments []CommentContext, processor func(CommentContext) ([]TaskRequest, error)) ([]storage.Task, error) <span class="cov8" title="1">{
        type commentResult struct {
                tasks   []TaskRequest
                err     error
                index   int
                context CommentContext
        }

        results := make(chan commentResult, len(comments))
        var wg sync.WaitGroup

        // Process each comment in parallel
        for i, commentCtx := range comments </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(index int, ctx CommentContext) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        tasks, err := processor(ctx)
                        results &lt;- commentResult{
                                tasks:   tasks,
                                err:     err,
                                index:   index,
                                context: ctx,
                        }
                }</span>(i, commentCtx)
        }

        // Wait for all goroutines to complete
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(results)
        }</span>()

        // Collect results
        <span class="cov8" title="1">var allTasks []TaskRequest
        var errors []error

        for result := range results </span><span class="cov8" title="1">{
                if result.err != nil </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Errorf("comment %d: %w", result.index, result.err))
                        // Record error in error tracker
                        if a.errorTracker != nil </span><span class="cov8" title="1">{
                                errorType := "processing_failed"
                                if strings.Contains(result.err.Error(), "json") </span><span class="cov0" title="0">{
                                        errorType = "json_parse"
                                }</span> else<span class="cov8" title="1"> if strings.Contains(result.err.Error(), "API") || strings.Contains(result.err.Error(), "execution failed") </span><span class="cov0" title="0">{
                                        errorType = "api_failure"
                                }</span> else<span class="cov8" title="1"> if strings.Contains(result.err.Error(), "context") || strings.Contains(result.err.Error(), "size") </span><span class="cov0" title="0">{
                                        errorType = "context_overflow"
                                }</span>
                                <span class="cov8" title="1">a.errorTracker.RecordCommentError(result.context, errorType, result.err.Error(), 0, false, 0, 0)</span>
                        }
                } else<span class="cov8" title="1"> {
                        allTasks = append(allTasks, result.tasks...)
                }</span>
        }

        // Report errors but continue if we have some successful results
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        for _, err := range errors </span><span class="cov0" title="0">{
                                fmt.Printf("  ⚠️  %v\n", err)
                        }</span>
                }
                <span class="cov8" title="1">if len(allTasks) == 0 </span><span class="cov8" title="1">{
                        // Show error summary when all processing failed
                        if a.errorTracker != nil &amp;&amp; a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                a.errorTracker.PrintErrorSummary()
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("all comment processing failed")</span>
                }
                // Show error summary when some processing failed
                <span class="cov0" title="0">if a.errorTracker != nil &amp;&amp; a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        a.errorTracker.PrintErrorSummary()
                }</span>
        }

        // Convert to storage tasks
        <span class="cov8" title="1">storageTasks := a.convertToStorageTasks(allTasks)

        // Apply deduplication
        dedupedTasks := a.deduplicateTasks(storageTasks)

        if a.config.AISettings.DeduplicationEnabled &amp;&amp; len(dedupedTasks) &lt; len(storageTasks) &amp;&amp; a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  🔄 Deduplication: %d tasks → %d tasks (removed %d duplicates)\n",
                        len(storageTasks), len(dedupedTasks), len(storageTasks)-len(dedupedTasks))
        }</span>

        <span class="cov8" title="1">return dedupedTasks, nil</span>
}

// generateTasksParallel processes comments in parallel using goroutines
func (a *Analyzer) generateTasksParallel(comments []CommentContext) ([]storage.Task, error) <span class="cov8" title="1">{
        if a.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                fmt.Printf("Processing %d comments in parallel...\n", len(comments))
        }</span>

        // Use stream processor if enabled, otherwise use traditional parallel processing
        <span class="cov8" title="1">if a.config.AISettings.StreamProcessingEnabled </span><span class="cov0" title="0">{
                streamProcessor := NewStreamProcessor(a)
                tasks, err := streamProcessor.ProcessCommentsStream(comments, a.processComment)
                if err == nil &amp;&amp; a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("✓ Generated %d tasks from %d comments (stream mode)\n", len(tasks), len(comments))
                }</span>
                <span class="cov0" title="0">return tasks, err</span>
        }

        // Traditional parallel processing
        <span class="cov8" title="1">tasks, err := a.processCommentsParallel(comments, a.processComment)
        if err == nil &amp;&amp; a.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                fmt.Printf("✓ Generated %d tasks from %d comments\n", len(tasks), len(comments))
        }</span>
        <span class="cov8" title="1">return tasks, err</span>
}

// processComment handles a single comment and returns tasks for it
func (a *Analyzer) processComment(ctx CommentContext) ([]TaskRequest, error) <span class="cov8" title="1">{
        // Check if comment needs special handling for large size
        const sizeThreshold = 20000 // 20KB threshold

        if len(ctx.Comment.Body) &gt; sizeThreshold </span><span class="cov0" title="0">{
                if a.config.AISettings.AutoSummarizeEnabled </span><span class="cov0" title="0">{
                        // Use intelligent summarization for large comments
                        return a.processLargeCommentWithSummarization(ctx)
                }</span> else<span class="cov0" title="0"> {
                        // Fall back to traditional chunking
                        chunker := NewCommentChunker(sizeThreshold)
                        return a.processLargeComment(ctx, chunker)
                }</span>
        }

        <span class="cov8" title="1">if a.config.AISettings.ValidationEnabled != nil &amp;&amp; *a.config.AISettings.ValidationEnabled </span><span class="cov0" title="0">{
                return a.processCommentWithValidation(ctx)
        }</span>

        <span class="cov8" title="1">prompt := a.buildCommentPrompt(ctx)
        return a.callClaudeCode(prompt)</span>
}

// processLargeComment handles comments that exceed size limits by chunking
func (a *Analyzer) processLargeComment(ctx CommentContext, chunker *CommentChunker) ([]TaskRequest, error) <span class="cov0" title="0">{
        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  📄 Large comment detected (ID: %d, size: %d bytes), chunking...\n",
                        ctx.Comment.ID, len(ctx.Comment.Body))
        }</span>

        <span class="cov0" title="0">chunks := chunker.ChunkComment(ctx.Comment)
        var allTasks []TaskRequest

        for i, chunk := range chunks </span><span class="cov0" title="0">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    Processing chunk %d/%d (size: %d bytes)\n", i+1, len(chunks), len(chunk.Body))
                }</span>

                // Create a new context with the chunked comment
                <span class="cov0" title="0">chunkCtx := CommentContext{
                        Comment:      chunk,
                        SourceReview: ctx.SourceReview,
                }

                // Process the chunk
                var tasks []TaskRequest
                var err error

                if a.config.AISettings.ValidationEnabled != nil &amp;&amp; *a.config.AISettings.ValidationEnabled </span><span class="cov0" title="0">{
                        tasks, err = a.processCommentWithValidation(chunkCtx)
                }</span> else<span class="cov0" title="0"> {
                        prompt := a.buildCommentPrompt(chunkCtx)
                        tasks, err = a.callClaudeCode(prompt)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("    ❌ Failed to process chunk %d: %v\n", i+1, err)
                        }</span>
                        // Continue with other chunks even if one fails
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">allTasks = append(allTasks, tasks...)</span>
        }

        <span class="cov0" title="0">if len(allTasks) == 0 &amp;&amp; len(chunks) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to process any chunks of large comment %d", ctx.Comment.ID)
        }</span>

        <span class="cov0" title="0">return allTasks, nil</span>
}

// processLargeCommentWithSummarization handles large comments by summarizing them
func (a *Analyzer) processLargeCommentWithSummarization(ctx CommentContext) ([]TaskRequest, error) <span class="cov0" title="0">{
        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  📝 Large comment detected (ID: %d, size: %d bytes), summarizing...\n",
                        ctx.Comment.ID, len(ctx.Comment.Body))
        }</span>

        // Create content summarizer
        <span class="cov0" title="0">summarizer := NewContentSummarizer(18000, a.config.AISettings.VerboseMode) // 18KB to leave room for prompt

        // Summarize the comment
        summarizedComment := summarizer.SummarizeComment(ctx.Comment)

        // Create new context with summarized comment
        summarizedCtx := CommentContext{
                Comment:      summarizedComment,
                SourceReview: ctx.SourceReview,
        }

        // Process the summarized comment
        var tasks []TaskRequest
        var err error

        if a.config.AISettings.ValidationEnabled != nil &amp;&amp; *a.config.AISettings.ValidationEnabled </span><span class="cov0" title="0">{
                tasks, err = a.processCommentWithValidation(summarizedCtx)
        }</span> else<span class="cov0" title="0"> {
                prompt := a.buildCommentPrompt(summarizedCtx)
                tasks, err = a.callClaudeCode(prompt)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // If summarization failed, fall back to chunking
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    ⚠️ Summarization failed, falling back to chunking: %v\n", err)
                }</span>
                <span class="cov0" title="0">chunker := NewCommentChunker(20000)
                return a.processLargeComment(ctx, chunker)</span>
        }

        <span class="cov0" title="0">if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  ✅ Successfully processed summarized comment: %d tasks generated\n", len(tasks))
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

// processCommentWithValidation validates individual comment JSON responses
func (a *Analyzer) processCommentWithValidation(ctx CommentContext) ([]TaskRequest, error) <span class="cov8" title="1">{
        // Pre-check: Calculate actual prompt size to avoid validation failures
        testPrompt := a.buildCommentPrompt(ctx)
        const maxPromptSize = 32 * 1024 // 32KB limit (same as validator)

        if len(testPrompt) &gt; maxPromptSize </span><span class="cov0" title="0">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  📄 Comment %d prompt too large (%d bytes), using chunking instead of validation\n",
                                ctx.Comment.ID, len(testPrompt))
                }</span>
                // Use chunking without validation for oversized prompts
                <span class="cov0" title="0">chunker := NewCommentChunker(20000)
                return a.processLargeComment(ctx, chunker)</span>
        }

        // Check if comment needs chunking based on size
        <span class="cov8" title="1">chunker := NewCommentChunker(20000) // 20KB chunks to leave room for prompt template
        if chunker.ShouldChunkComment(ctx.Comment) </span><span class="cov0" title="0">{
                // Process large comment with chunking (no validation for chunks)
                return a.processLargeComment(ctx, chunker)
        }</span>

        <span class="cov8" title="1">validator := NewTaskValidator(a.config)

        for attempt := 1; attempt &lt;= validator.maxRetries; attempt++ </span><span class="cov8" title="1">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    🔄 Comment %d validation attempt %d/%d\n", ctx.Comment.ID, attempt, validator.maxRetries)
                }</span>

                <span class="cov8" title="1">prompt := a.buildCommentPrompt(ctx)
                tasks, err := a.callClaudeCode(prompt)
                if err != nil </span><span class="cov8" title="1">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("    ❌ Comment %d generation failed: %v\n", ctx.Comment.ID, err)
                        }</span>
                        // If it's a prompt size error, no point in retrying individual comments
                        <span class="cov8" title="1">if strings.Contains(err.Error(), "prompt size") &amp;&amp; strings.Contains(err.Error(), "exceeds maximum limit") </span><span class="cov8" title="1">{
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("    ⚠️  Comment %d prompt size limit exceeded - stopping retries\n", ctx.Comment.ID)
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Stage 1: Format validation for this comment's tasks
                <span class="cov0" title="0">formatResult, err := validator.validateFormat(tasks)
                if err != nil </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("    ❌ Comment %d format validation failed: %v\n", ctx.Comment.ID, err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if !formatResult.IsValid </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("    ⚠️  Comment %d format issues (score: %.2f)\n", ctx.Comment.ID, formatResult.Score)
                        }</span>
                        <span class="cov0" title="0">if attempt == validator.maxRetries </span><span class="cov0" title="0">{
                                // Use best attempt on final try
                                return formatResult.Tasks, nil
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Stage 2: Content validation for this comment's tasks
                // Create a mini-review with only the current comment for validation context
                <span class="cov0" title="0">miniReview := github.Review{
                        ID:       ctx.SourceReview.ID,
                        Body:     ctx.SourceReview.Body,
                        Comments: []github.Comment{ctx.Comment}, // Only include the current comment
                }
                miniReviews := []github.Review{miniReview}
                contentResult, err := validator.validateContent(formatResult.Tasks, miniReviews)
                if err != nil </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("    ❌ Comment %d content validation failed: %v\n", ctx.Comment.ID, err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    ✅ Comment %d validation passed (score: %.2f)\n", ctx.Comment.ID, contentResult.Score)
                }</span>

                // Return validated tasks
                <span class="cov0" title="0">return formatResult.Tasks, nil</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("comment %d validation failed after %d attempts", ctx.Comment.ID, validator.maxRetries)</span>
}

// buildCommentPrompt creates a focused prompt for analyzing a single comment
func (a *Analyzer) buildCommentPrompt(ctx CommentContext) string <span class="cov8" title="1">{
        var languageInstruction string
        if a.config.AISettings.UserLanguage != "" </span><span class="cov8" title="1">{
                languageInstruction = fmt.Sprintf("IMPORTANT: Generate task descriptions in %s language.\n", a.config.AISettings.UserLanguage)
        }</span>

        <span class="cov8" title="1">priorityPrompt := a.config.GetPriorityPrompt()

        // Add nitpick handling instructions
        nitpickInstruction := a.buildNitpickInstruction()

        // Build example task using proper JSON marshaling
        exampleTask := map[string]interface{}{
                "description":       "Actionable task description in specified language",
                "origin_text":       "Original review comment text (preserve exactly)",
                "priority":          "critical|high|medium|low",
                "source_review_id":  ctx.SourceReview.ID,
                "source_comment_id": ctx.Comment.ID,
                "file":              ctx.Comment.File,
                "line":              ctx.Comment.Line,
                "task_index":        0,
        }

        exampleJSON, err := json.MarshalIndent([]interface{}{exampleTask}, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple format if marshaling fails
                exampleJSON = []byte(fmt.Sprintf(`[
  {
    "description": "Actionable task description in specified language",
    "origin_text": "Original review comment text (preserve exactly)",
    "priority": "critical|high|medium|low",
    "source_review_id": %d,
    "source_comment_id": %d,
    "file": "%s",
    "line": %d,
    "task_index": 0
  }
]`, ctx.SourceReview.ID, ctx.Comment.ID, ctx.Comment.File, ctx.Comment.Line))
        }</span>

        <span class="cov8" title="1">prompt := fmt.Sprintf(`You are an AI assistant helping to analyze GitHub PR review comments and generate actionable tasks.

%s
%s
%s

Analyze this single comment and create actionable tasks if needed:

Review Context:
- Review ID: %d
- Reviewer: %s
- Review State: %s

Comment Details:
- Comment ID: %d
- Author: %s
- File: %s:%d
- Comment Text: %s

%s

CRITICAL: Return response as JSON array with this EXACT format:
%s

Requirements:
1. PRESERVE original comment text in 'origin_text' field exactly as written
2. Generate clear, actionable 'description' in the specified user language
3. Create appropriate number of tasks based on the comment's content
4. Each distinct actionable item should be a separate task
5. Assign task_index starting from 0 for multiple tasks
6. Only create tasks for comments requiring developer action
7. Consider if this comment has already been resolved in discussion chains
8. Return empty array [] if no actionable tasks are needed

Task Generation Guidelines:
- Create separate tasks for logically distinct actions
- If a comment mentions multiple unrelated issues, create separate tasks
- Ensure each task is self-contained and actionable
- Don't artificially combine unrelated items
- AI deduplication will handle any redundancy later`,
                languageInstruction,
                priorityPrompt,
                nitpickInstruction,
                ctx.SourceReview.ID,
                ctx.SourceReview.Reviewer,
                ctx.SourceReview.State,
                ctx.Comment.ID,
                ctx.Comment.Author,
                ctx.Comment.File,
                ctx.Comment.Line,
                ctx.Comment.Body,
                a.buildRepliesContext(ctx.Comment),
                string(exampleJSON))

        return prompt</span>
}

// buildRepliesContext formats reply chain for context
func (a *Analyzer) buildRepliesContext(comment github.Comment) string <span class="cov8" title="1">{
        if len(comment.Replies) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov0" title="0">var repliesContext strings.Builder
        repliesContext.WriteString("\nReply Chain (for context):\n")
        for _, reply := range comment.Replies </span><span class="cov0" title="0">{
                repliesContext.WriteString(fmt.Sprintf("  - %s: %s\n", reply.Author, reply.Body))
        }</span>

        <span class="cov0" title="0">return repliesContext.String()</span>
}

// findClaudeCommand searches for Claude CLI using the shared utility function
// func (a *Analyzer) findClaudeCommand() (string, error) {
//     return FindClaudeCommand(a.config.AISettings.ClaudePath)
// }

// generateTasksParallelWithValidation processes comments in parallel with validation enabled
func (a *Analyzer) generateTasksParallelWithValidation(comments []CommentContext) ([]storage.Task, error) <span class="cov8" title="1">{
        // Use stream processor if enabled, otherwise use traditional parallel processing
        if a.config.AISettings.StreamProcessingEnabled </span><span class="cov0" title="0">{
                streamProcessor := NewStreamProcessor(a)
                tasks, err := streamProcessor.ProcessCommentsStream(comments, a.processCommentWithValidation)
                if err == nil &amp;&amp; a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("✓ Generated %d tasks from %d comments with validation (stream mode)\n", len(tasks), len(comments))
                }</span>
                <span class="cov0" title="0">return tasks, err</span>
        }

        // Traditional parallel processing
        <span class="cov8" title="1">tasks, err := a.processCommentsParallel(comments, a.processCommentWithValidation)
        if err == nil </span><span class="cov0" title="0">{
                // Tasks are already deduplicated in processCommentsParallel
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("✓ Generated %d tasks from %d comments with validation\n", len(tasks), len(comments))
                }</span>
        }
        <span class="cov8" title="1">return tasks, err</span>
}

// isCommentResolved checks if a comment has been marked as resolved/addressed
func (a *Analyzer) isCommentResolved(comment github.Comment) bool <span class="cov8" title="1">{
        // Check for common resolution markers in the comment body or replies
        resolvedMarkers := []string{
                "✅ Addressed in commit",
                "✅ Fixed in commit",
                "✅ Resolved in commit",
                "Addressed in commit",
                "Fixed in commit",
                "Resolved in commit",
        }

        // Check comment body
        commentText := strings.ToLower(comment.Body)
        for _, marker := range resolvedMarkers </span><span class="cov8" title="1">{
                if strings.Contains(commentText, strings.ToLower(marker)) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check replies for resolution markers
        <span class="cov8" title="1">for _, reply := range comment.Replies </span><span class="cov0" title="0">{
                replyText := strings.ToLower(reply.Body)
                for _, marker := range resolvedMarkers </span><span class="cov0" title="0">{
                        if strings.Contains(replyText, strings.ToLower(marker)) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// extractJSON extracts JSON content from Claude response with improved robustness
func (a *Analyzer) extractJSON(response string) string <span class="cov8" title="1">{
        // First, check if the response contains a markdown code block
        if strings.Contains(response, "```json") </span><span class="cov8" title="1">{
                // Extract content between ```json and ```
                start := strings.Index(response, "```json")
                if start != -1 </span><span class="cov8" title="1">{
                        start += 7 // Skip past "```json"
                        end := strings.Index(response[start:], "```")
                        if end != -1 </span><span class="cov8" title="1">{
                                return strings.TrimSpace(response[start : start+end])
                        }</span>
                }
        } else<span class="cov8" title="1"> if strings.Contains(response, "```") </span><span class="cov0" title="0">{
                // Extract content between ``` and ```
                start := strings.Index(response, "```")
                if start != -1 </span><span class="cov0" title="0">{
                        start += 3 // Skip past "```"
                        // Skip language identifier if present
                        if newlineIdx := strings.Index(response[start:], "\n"); newlineIdx != -1 &amp;&amp; newlineIdx &lt; 20 </span><span class="cov0" title="0">{
                                start += newlineIdx + 1
                        }</span>
                        <span class="cov0" title="0">end := strings.Index(response[start:], "```")
                        if end != -1 </span><span class="cov0" title="0">{
                                return strings.TrimSpace(response[start : start+end])
                        }</span>
                }
        }

        // If no code blocks, try to find JSON array or object
        <span class="cov8" title="1">response = strings.TrimSpace(response)

        // Look for JSON array first
        jsonStart := strings.Index(response, "[")
        jsonEnd := strings.LastIndex(response, "]")

        if jsonStart != -1 &amp;&amp; jsonEnd != -1 &amp;&amp; jsonStart &lt; jsonEnd </span><span class="cov8" title="1">{
                // Validate that this is likely the main JSON content
                // by checking if there's significant text before the JSON
                textBefore := strings.TrimSpace(response[:jsonStart])
                if len(textBefore) &gt; 100 </span><span class="cov0" title="0">{
                        // There's a lot of text before the JSON, try to find the actual JSON
                        // Look for the last occurrence of a newline before the JSON array
                        lastNewline := strings.LastIndex(response[:jsonStart], "\n")
                        if lastNewline != -1 </span><span class="cov0" title="0">{
                                jsonStart = strings.Index(response[lastNewline:], "[") + lastNewline
                        }</span>
                }
                <span class="cov8" title="1">return response[jsonStart : jsonEnd+1]</span>
        }

        // Try to find JSON object and wrap it in array
        <span class="cov8" title="1">objStart := strings.Index(response, "{")
        objEnd := strings.LastIndex(response, "}")
        if objStart != -1 &amp;&amp; objEnd != -1 &amp;&amp; objStart &lt; objEnd </span><span class="cov8" title="1">{
                objContent := response[objStart : objEnd+1]
                if a.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                        fmt.Printf("  🐛 Found JSON object instead of array: %s\n", objContent)
                }</span>
                // Wrap single object in array
                <span class="cov8" title="1">return "[" + objContent + "]"</span>
        }

        // Check for common non-JSON responses that should return empty array
        <span class="cov8" title="1">lowerResponse := strings.ToLower(response)
        emptyResponsePatterns := []string{
                "no actionable tasks",
                "no tasks needed",
                "[]",
                "empty array",
                "no action required",
                "already resolved",
                "no implementation needed",
        }

        for _, pattern := range emptyResponsePatterns </span><span class="cov8" title="1">{
                if strings.Contains(lowerResponse, pattern) </span><span class="cov8" title="1">{
                        return "[]"
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// isCodeRabbitNitpickResponse checks if the response is about CodeRabbit nitpicks with no actionable tasks
func (a *Analyzer) isCodeRabbitNitpickResponse(response string) bool <span class="cov8" title="1">{
        lowerResponse := strings.ToLower(response)

        // Check for CodeRabbit-style responses about nitpicks
        codeRabbitPatterns := []string{
                "actionable comments posted: 0",
                "nitpick comments",
                "need to analyze if it contains any actionable tasks",
                "no actionable tasks in the nitpick",
                "nitpick suggestions don't require",
        }

        nitpickCount := 0
        for _, pattern := range codeRabbitPatterns </span><span class="cov8" title="1">{
                if strings.Contains(lowerResponse, pattern) </span><span class="cov8" title="1">{
                        nitpickCount++
                }</span>
        }

        // If we find multiple indicators of CodeRabbit nitpick responses, it's likely a nitpick-only comment
        <span class="cov8" title="1">return nitpickCount &gt;= 1</span>
}

// buildNitpickInstruction generates nitpick processing instructions based on configuration
func (a *Analyzer) buildNitpickInstruction() string <span class="cov8" title="1">{
        if a.config.AISettings.ProcessNitpickComments </span><span class="cov8" title="1">{
                return fmt.Sprintf(`
IMPORTANT: Nitpick Comment Processing Instructions:
- Process nitpick comments from review bots (like CodeRabbit) even when marked with "Actionable comments posted: 0"
- Ignore "Actionable comments posted: 0" headers when nitpick content is present
- Extract actionable tasks from nitpick sections and collapsible details
- Set priority to "%s" for tasks generated from nitpick comments
- Look for nitpick content in &lt;details&gt; blocks, summaries, and structured formats
- Do not skip comments containing valuable improvement suggestions just because they're labeled as nitpicks

`, a.config.AISettings.NitpickPriority)
        }</span> else<span class="cov8" title="1"> {
                return `
IMPORTANT: Nitpick Comment Processing:
- Skip nitpick comments and suggestions
- Ignore CodeRabbit nitpick sections
- Focus only on actionable review feedback requiring implementation

`
        }</span>
}

// deduplicateTasks removes duplicate tasks based on comment ID and similarity
func (a *Analyzer) deduplicateTasks(tasks []storage.Task) []storage.Task <span class="cov8" title="1">{
        if !a.config.AISettings.DeduplicationEnabled </span><span class="cov8" title="1">{
                return tasks
        }</span>

        // Use AI-powered deduplication if available
        <span class="cov8" title="1">deduplicator := NewTaskDeduplicator(a.config)

        // First, perform AI-based deduplication across all tasks
        deduplicatedTasks, err := deduplicator.DeduplicateTasks(tasks)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  AI deduplication failed, falling back to rule-based: %v\n", err)
                // Fall back to the original similarity-based deduplication
                return a.deduplicateTasksRuleBased(tasks)
        }</span>

        // Group tasks by comment ID for per-comment deduplication
        <span class="cov8" title="1">tasksByComment := make(map[int64][]storage.Task)
        for _, task := range deduplicatedTasks </span><span class="cov8" title="1">{
                tasksByComment[task.SourceCommentID] = append(tasksByComment[task.SourceCommentID], task)
        }</span>

        <span class="cov8" title="1">var result []storage.Task
        for commentID, commentTasks := range tasksByComment </span><span class="cov8" title="1">{
                // Skip max_tasks_per_comment limit when using AI deduplication
                // The AI will handle determining the appropriate number of tasks
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  ✨ Comment %d: %d unique tasks identified by AI\n", commentID, len(commentTasks))
                }</span>

                <span class="cov8" title="1">result = append(result, commentTasks...)</span>
        }

        <span class="cov8" title="1">return result</span>
}

// deduplicateTasksRuleBased is the fallback rule-based deduplication
func (a *Analyzer) deduplicateTasksRuleBased(tasks []storage.Task) []storage.Task <span class="cov0" title="0">{
        // Group tasks by comment ID
        tasksByComment := make(map[int64][]storage.Task)
        for _, task := range tasks </span><span class="cov0" title="0">{
                tasksByComment[task.SourceCommentID] = append(tasksByComment[task.SourceCommentID], task)
        }</span>

        <span class="cov0" title="0">var result []storage.Task

        for commentID, commentTasks := range tasksByComment </span><span class="cov0" title="0">{
                // Apply max tasks per comment limit (only in rule-based mode)
                if len(commentTasks) &gt; a.config.AISettings.MaxTasksPerComment </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  🔄 Comment %d: Limiting from %d to %d tasks (rule-based)\n",
                                        commentID, len(commentTasks), a.config.AISettings.MaxTasksPerComment)
                        }</span>
                        // Sort by priority to keep the most important tasks
                        <span class="cov0" title="0">sortedTasks := a.sortTasksByPriority(commentTasks)
                        commentTasks = sortedTasks[:a.config.AISettings.MaxTasksPerComment]</span>
                }

                // Apply similarity deduplication within the comment's tasks
                <span class="cov0" title="0">deduped := a.deduplicateSimilarTasks(commentTasks)
                result = append(result, deduped...)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// sortTasksByPriority sorts tasks by priority (critical &gt; high &gt; medium &gt; low)
func (a *Analyzer) sortTasksByPriority(tasks []storage.Task) []storage.Task <span class="cov8" title="1">{
        // Create a copy to avoid modifying the original
        sorted := make([]storage.Task, len(tasks))
        copy(sorted, tasks)

        priorityOrder := map[string]int{
                "critical": 0,
                "high":     1,
                "medium":   2,
                "low":      3,
        }

        // Sort by priority, then by task index using Go's built-in sort.Slice
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov8" title="1">{
                pi := priorityOrder[sorted[i].Priority]
                pj := priorityOrder[sorted[j].Priority]

                if pi != pj </span><span class="cov8" title="1">{
                        return pi &lt; pj
                }</span>
                <span class="cov8" title="1">return sorted[i].TaskIndex &lt; sorted[j].TaskIndex</span>
        })

        <span class="cov8" title="1">return sorted</span>
}

// deduplicateSimilarTasks removes tasks with similar descriptions
func (a *Analyzer) deduplicateSimilarTasks(tasks []storage.Task) []storage.Task <span class="cov8" title="1">{
        if len(tasks) &lt;= 1 </span><span class="cov8" title="1">{
                return tasks
        }</span>

        // First, sort tasks by priority to ensure we process higher priority tasks first
        <span class="cov8" title="1">sortedTasks := a.sortTasksByPriority(tasks)

        var result []storage.Task
        seen := make(map[int]bool)

        for i, task1 := range sortedTasks </span><span class="cov8" title="1">{
                if seen[i] </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check similarity with remaining tasks
                <span class="cov8" title="1">for j := i + 1; j &lt; len(sortedTasks); j++ </span><span class="cov8" title="1">{
                        if seen[j] </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">similarity := a.calculateSimilarity(task1.Description, sortedTasks[j].Description)
                        if similarity &gt;= a.config.AISettings.SimilarityThreshold </span><span class="cov8" title="1">{
                                // Since we're sorted by priority, task1 has higher or equal priority
                                // Always mark the later task (lower or equal priority) as duplicate
                                seen[j] = true
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("  🔄 Deduplicating task: '%s' (similar to '%s', similarity: %.2f)\n",
                                                sortedTasks[j].Description, task1.Description, similarity)
                                }</span>
                        }
                }

                <span class="cov8" title="1">if !seen[i] </span><span class="cov8" title="1">{
                        result = append(result, task1)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// calculateSimilarity calculates the similarity between two strings (0.0 to 1.0)
func (a *Analyzer) calculateSimilarity(s1, s2 string) float64 <span class="cov8" title="1">{
        // Simple Jaccard similarity based on words
        words1 := strings.Fields(strings.ToLower(s1))
        words2 := strings.Fields(strings.ToLower(s2))

        if len(words1) == 0 &amp;&amp; len(words2) == 0 </span><span class="cov8" title="1">{
                return 1.0
        }</span>
        <span class="cov8" title="1">if len(words1) == 0 || len(words2) == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        // Create word sets
        <span class="cov8" title="1">set1 := make(map[string]bool)
        set2 := make(map[string]bool)

        for _, w := range words1 </span><span class="cov8" title="1">{
                set1[w] = true
        }</span>
        <span class="cov8" title="1">for _, w := range words2 </span><span class="cov8" title="1">{
                set2[w] = true
        }</span>

        // Calculate intersection and union
        <span class="cov8" title="1">intersection := 0
        for w := range set1 </span><span class="cov8" title="1">{
                if set2[w] </span><span class="cov8" title="1">{
                        intersection++
                }</span>
        }

        <span class="cov8" title="1">union := len(set1) + len(set2) - intersection

        return float64(intersection) / float64(union)</span>
}

// getPriorityValue returns numeric value for priority comparison
func (a *Analyzer) getPriorityValue(priority string) int <span class="cov8" title="1">{
        switch priority </span>{
        case "critical":<span class="cov8" title="1">
                return 0</span>
        case "high":<span class="cov8" title="1">
                return 1</span>
        case "medium":<span class="cov8" title="1">
                return 2</span>
        case "low":<span class="cov8" title="1">
                return 3</span>
        default:<span class="cov8" title="1">
                return 4</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ai

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
)

// RealClaudeClient implements ClaudeClient using actual Claude Code CLI
type RealClaudeClient struct {
        claudePath string
}

// NewRealClaudeClient creates a new real Claude client
func NewRealClaudeClient() (*RealClaudeClient, error) <span class="cov8" title="1">{
        claudePath, err := findClaudeCLI()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("claude command not found: %w\n\nTo resolve this issue:\n1. Install Claude CLI: npm install -g @anthropic-ai/claude-code\n2. Or ensure Claude CLI is in your PATH\n3. Or create an alias 'claude' pointing to your Claude CLI installation\n4. Or place it in one of these locations:\n   - ~/.claude/local/claude\n   - ~/.npm-global/bin/claude\n   - ~/.volta/bin/claude", err)
        }</span>

        // Check if Claude is already in PATH
        <span class="cov8" title="1">if _, pathErr := exec.LookPath("claude"); pathErr != nil </span><span class="cov8" title="1">{
                // Claude found but not in PATH, create symlink
                log.Printf("ℹ️  Claude CLI found at %s but not in PATH", claudePath)

                if err := ensureClaudeAvailable(claudePath); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to ensure claude availability: %w", err)
                }</span>

                <span class="cov8" title="1">log.Printf("✓ Created symlink at ~/.local/bin/claude for reviewtask compatibility")</span>
        }

        <span class="cov8" title="1">return &amp;RealClaudeClient{claudePath: claudePath}, nil</span>
}

// findClaudeCLI implements comprehensive Claude CLI detection strategy
func findClaudeCLI() (string, error) <span class="cov8" title="1">{
        // Try standard PATH first
        if path, err := exec.LookPath("claude"); err == nil </span><span class="cov8" title="1">{
                return path, nil
        }</span>

        // Try to resolve alias
        <span class="cov8" title="1">if aliasPath, err := resolveClaudeAlias(); err == nil &amp;&amp; aliasPath != "" </span><span class="cov8" title="1">{
                // Verify the resolved alias path is valid
                if isValidClaudeCLI(aliasPath) </span><span class="cov8" title="1">{
                        return aliasPath, nil
                }</span>
        }

        // Get home directory in a cross-platform way
        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to HOME env var if UserHomeDir fails
                homeDir = os.Getenv("HOME")
                if homeDir == "" </span><span class="cov0" title="0">{
                        homeDir = os.Getenv("USERPROFILE") // Windows fallback
                }</span>
        }

        // Try common installation locations
        <span class="cov8" title="1">var commonPaths []string

        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Windows-specific paths
                commonPaths = []string{
                        filepath.Join(homeDir, ".claude", "local", "claude.exe"),
                        filepath.Join(homeDir, ".npm-global", "claude.cmd"),
                        filepath.Join(homeDir, ".npm-global", "claude.exe"),
                        filepath.Join(homeDir, ".volta", "bin", "claude.exe"),
                        filepath.Join(homeDir, ".volta", "bin", "claude.cmd"),
                        filepath.Join(homeDir, "AppData", "Local", "Programs", "claude", "claude.exe"),
                        filepath.Join(homeDir, "AppData", "Roaming", "npm", "claude.cmd"),
                        filepath.Join(homeDir, "AppData", "Roaming", "npm", "claude.exe"),
                }
        }</span> else<span class="cov8" title="1"> {
                // Unix-like paths
                commonPaths = []string{
                        filepath.Join(homeDir, ".claude/local/claude"),
                        filepath.Join(homeDir, ".npm-global/bin/claude"),
                        filepath.Join(homeDir, ".volta/bin/claude"),
                        "/usr/local/bin/claude",
                        "/opt/homebrew/bin/claude",
                        filepath.Join(homeDir, ".local/bin/claude"),
                }
        }</span>

        // Add npm global prefix bin directory (for nvm and other npm managers)
        <span class="cov8" title="1">if npmPrefix := getNpmPrefix(); npmPrefix != "" </span><span class="cov8" title="1">{
                if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                        // On Windows, npm installs .cmd files
                        commonPaths = append(commonPaths,
                                filepath.Join(npmPrefix, "claude.cmd"),
                                filepath.Join(npmPrefix, "claude.exe"))
                }</span> else<span class="cov8" title="1"> {
                        npmClaudePath := filepath.Join(npmPrefix, "bin", "claude")
                        commonPaths = append(commonPaths, npmClaudePath)
                }</span>
        }

        <span class="cov8" title="1">for _, path := range commonPaths </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        // Verify it's executable by running version check
                        if isValidClaudeCLI(path) </span><span class="cov8" title="1">{
                                return path, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return "", fmt.Errorf("claude CLI not found in PATH or common installation locations")</span>
}

// resolveClaudeAlias attempts to resolve claude alias from shell configuration
func resolveClaudeAlias() (string, error) <span class="cov8" title="1">{
        // Skip on Windows as Unix shell commands won't work
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("shell alias resolution not supported on Windows")
        }</span>

        // Detect the user's shell
        <span class="cov8" title="1">shell := os.Getenv("SHELL")
        if shell == "" </span><span class="cov0" title="0">{
                shell = "/bin/bash"
        }</span>

        // Extract shell name from path
        <span class="cov8" title="1">shellName := filepath.Base(shell)

        // Try to get alias definition using shell built-in alias command
        var cmd *exec.Cmd
        switch shellName </span>{
        case "bash", "zsh":<span class="cov8" title="1">
                // Use type command which is more reliable for alias resolution
                cmd = exec.Command(shell, "-i", "-c", "type -p claude 2&gt;/dev/null || alias claude 2&gt;/dev/null | grep -oE \"='[^']*'|=\\\"[^\\\"]*\\\"|=[^[:space:]]+\" | sed 's/^=//' | sed 's/^[\"'\"'\"']//;s/[\"'\"'\"']$//'")</span>
        case "fish":<span class="cov0" title="0">
                // Fish shell has different syntax
                cmd = exec.Command(shell, "-c", "functions -D claude 2&gt;/dev/null &amp;&amp; which claude 2&gt;/dev/null")</span>
        default:<span class="cov0" title="0">
                // For other shells, try generic approach
                cmd = exec.Command(shell, "-i", "-c", "type -p claude 2&gt;/dev/null")</span>
        }

        <span class="cov8" title="1">output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                // Try alternative method: check common shell config files directly
                return checkShellConfigFiles()
        }</span>

        <span class="cov8" title="1">aliasOutput := strings.TrimSpace(string(output))
        if aliasOutput == "" </span><span class="cov8" title="1">{
                // Shell command succeeded but returned empty output
                // Try alternative method: check common shell config files directly
                return checkShellConfigFiles()
        }</span>

        // Parse the alias output
        <span class="cov8" title="1">aliasPath := parseAliasOutput(aliasOutput)
        if aliasPath == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not parse alias output")
        }</span>

        // Resolve the full path of the aliased command
        <span class="cov8" title="1">if !filepath.IsAbs(aliasPath) </span><span class="cov0" title="0">{
                resolvedPath, err := exec.LookPath(aliasPath)
                if err == nil </span><span class="cov0" title="0">{
                        aliasPath = resolvedPath
                }</span>
        }

        <span class="cov8" title="1">return aliasPath, nil</span>
}

// parseAliasOutput extracts the actual command from various alias formats
func parseAliasOutput(output string) string <span class="cov8" title="1">{
        // Remove any alias prefix
        output = strings.TrimPrefix(output, "alias claude=")

        // First preserve the original output for complex commands
        originalOutput := output

        // Handle various quote formats
        output = strings.Trim(output, "'\"")

        // Special handling for paths with spaces
        if strings.Contains(originalOutput, "\"") &amp;&amp; strings.Contains(output, " ") </span><span class="cov8" title="1">{
                // This was a quoted path with spaces
                return output
        }</span>

        // If it's a Windows path (contains backslash), return as-is
        <span class="cov8" title="1">if strings.Contains(output, "\\") </span><span class="cov0" title="0">{
                return output
        }</span>

        // If the alias contains arguments or complex commands, extract just the executable
        // Handle cases like: node /path/to/claude.js, npx @anthropic-ai/claude-code, etc.
        <span class="cov8" title="1">parts := strings.Fields(output)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // First part is the command
        <span class="cov8" title="1">command := parts[0]

        // If command is a interpreter (node, python, etc.) and has a script path, return full command
        interpreters := []string{"node", "node.exe", "python", "python.exe", "python3", "python3.exe"}
        for _, interp := range interpreters </span><span class="cov8" title="1">{
                if command == interp &amp;&amp; len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        // Check if the second part is a file path
                        scriptPath := parts[1]
                        if filepath.IsAbs(scriptPath) || strings.Contains(scriptPath, "/") || strings.Contains(scriptPath, "\\") </span><span class="cov8" title="1">{
                                return output // Return the full command with interpreter
                        }</span>
                }
        }

        <span class="cov8" title="1">return command</span>
}

// checkShellConfigFiles directly reads shell configuration files for alias definitions
func checkShellConfigFiles() (string, error) <span class="cov8" title="1">{
        // Skip on Windows as Unix shell config files don't exist
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("shell config file checking not supported on Windows")
        }</span>

        <span class="cov8" title="1">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to HOME env var
                home = os.Getenv("HOME")
                if home == "" </span><span class="cov0" title="0">{
                        home = os.Getenv("USERPROFILE") // Windows fallback
                }</span>
                <span class="cov0" title="0">if home == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unable to determine home directory")
                }</span>
        }

        // Common shell config files to check
        <span class="cov8" title="1">configFiles := []string{
                filepath.Join(home, ".bashrc"),
                filepath.Join(home, ".bash_profile"),
                filepath.Join(home, ".zshrc"),
                filepath.Join(home, ".config/fish/config.fish"),
        }

        for _, configFile := range configFiles </span><span class="cov8" title="1">{
                if aliasPath, found := searchAliasInFile(configFile); found </span><span class="cov8" title="1">{
                        return aliasPath, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("no alias found in shell config files")</span>
}

// searchAliasInFile searches for claude alias in a specific config file
func searchAliasInFile(filepath string) (string, bool) <span class="cov8" title="1">{
        content, err := os.ReadFile(filepath)
        if err != nil </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                // Skip comments
                if strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for alias definition
                <span class="cov8" title="1">if strings.HasPrefix(line, "alias claude=") </span><span class="cov8" title="1">{
                        aliasValue := strings.TrimPrefix(line, "alias claude=")
                        aliasPath := parseAliasOutput(aliasValue)
                        if aliasPath != "" </span><span class="cov8" title="1">{
                                return aliasPath, true
                        }</span>
                }
        }

        <span class="cov8" title="1">return "", false</span>
}

// isValidClaudeCLI verifies that the found executable is actually Claude CLI
func isValidClaudeCLI(path string) bool <span class="cov8" title="1">{
        // Handle interpreter-based commands (e.g., "node /path/to/claude.js")
        parts := strings.Fields(path)
        var cmd *exec.Cmd

        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                // Command with interpreter
                interpreter := parts[0]
                scriptAndArgs := append(parts[1:], "--version")
                cmd = exec.Command(interpreter, scriptAndArgs...)
        }</span> else<span class="cov8" title="1"> {
                // Direct command
                cmd = exec.Command(path, "--version")
        }</span>

        <span class="cov8" title="1">output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        // Check if output contains expected Claude CLI version pattern
        <span class="cov8" title="1">outputStr := strings.ToLower(string(output))
        return strings.Contains(outputStr, "claude") || strings.Contains(outputStr, "anthropic")</span>
}

// ensureClaudeAvailable creates symlink if Claude is not in PATH
func ensureClaudeAvailable(claudePath string) error <span class="cov8" title="1">{
        // Check if claude is already available in PATH
        if _, err := exec.LookPath("claude"); err == nil </span><span class="cov8" title="1">{
                return nil // Already available in PATH
        }</span>

        // Skip symlink creation on Windows as it requires admin privileges
        <span class="cov8" title="1">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // On Windows, we rely on claude being in PATH or using full path
                return nil
        }</span>

        // Create symlink in ~/.local/bin (which is commonly in PATH)
        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        <span class="cov8" title="1">localBin := filepath.Join(homeDir, ".local/bin")
        if err := os.MkdirAll(localBin, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ~/.local/bin directory: %w", err)
        }</span>

        <span class="cov8" title="1">symlinkPath := filepath.Join(localBin, "claude")

        // Remove existing symlink if it exists
        if _, err := os.Lstat(symlinkPath); err == nil </span><span class="cov0" title="0">{
                if err := os.Remove(symlinkPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove existing symlink: %w", err)
                }</span>
        }

        // Create new symlink
        <span class="cov8" title="1">if err := os.Symlink(claudePath, symlinkPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create symlink: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CleanupClaudeSymlink removes symlinks created by reviewtask
func CleanupClaudeSymlink() error <span class="cov8" title="1">{
        // Skip on Windows as we don't create symlinks there
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        <span class="cov8" title="1">symlinkPath := filepath.Join(homeDir, ".local/bin", "claude")

        // Check if it's our symlink (not a real installation)
        if info, err := os.Lstat(symlinkPath); err == nil &amp;&amp; info.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov8" title="1">{
                target, err := os.Readlink(symlinkPath)
                if err == nil &amp;&amp; isReviewtaskManagedSymlink(target) </span><span class="cov8" title="1">{
                        return os.Remove(symlinkPath)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isReviewtaskManagedSymlink checks if symlink target is managed by reviewtask
func isReviewtaskManagedSymlink(target string) bool <span class="cov8" title="1">{
        // Check if target points to common npm/Node.js installation paths
        reviewtaskManagedPaths := []string{
                ".claude/local/claude",
                ".npm-global/bin/claude",
                ".volta/bin/claude",
        }

        for _, managedPath := range reviewtaskManagedPaths </span><span class="cov8" title="1">{
                if strings.Contains(target, managedPath) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// getNpmPrefix gets the npm global installation prefix
func getNpmPrefix() string <span class="cov8" title="1">{
        cmd := exec.Command("npm", "config", "get", "prefix")
        output, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">prefix := strings.TrimSpace(string(output))
        if prefix == "" || prefix == "undefined" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return prefix</span>
}

// Execute runs Claude with the given input
func (c *RealClaudeClient) Execute(ctx context.Context, input string, outputFormat string) (string, error) <span class="cov0" title="0">{
        args := []string{}
        if outputFormat != "" </span><span class="cov0" title="0">{
                args = append(args, "--output-format", outputFormat)
        }</span>

        <span class="cov0" title="0">var cmd *exec.Cmd

        // Check if claudePath contains interpreter command (e.g., "node /path/to/claude.js")
        if strings.Contains(c.claudePath, " ") </span><span class="cov0" title="0">{
                // Parse command with interpreter
                parts := strings.Fields(c.claudePath)
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        // First part is interpreter, rest are script and its args
                        interpreter := parts[0]
                        scriptAndArgs := append(parts[1:], args...)
                        cmd = exec.CommandContext(ctx, interpreter, scriptAndArgs...)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to direct execution
                        cmd = exec.CommandContext(ctx, c.claudePath, args...)
                }</span>
        } else<span class="cov0" title="0"> {
                // Direct command execution
                cmd = exec.CommandContext(ctx, c.claudePath, args...)
        }</span>

        <span class="cov0" title="0">cmd.Stdin = strings.NewReader(input)

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("claude execution failed: %w, stderr: %s", err, stderr.String())
        }</span>

        <span class="cov0" title="0">return stdout.String(), nil</span>
}

// RealCommandExecutor implements CommandExecutor using os/exec
type RealCommandExecutor struct{}

// NewRealCommandExecutor creates a new real command executor
func NewRealCommandExecutor() *RealCommandExecutor <span class="cov0" title="0">{
        return &amp;RealCommandExecutor{}
}</span>

// Execute runs a system command
func (e *RealCommandExecutor) Execute(ctx context.Context, name string, args []string, stdin io.Reader) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, name, args...)
        if stdin != nil </span><span class="cov0" title="0">{
                cmd.Stdin = stdin
        }</span>

        <span class="cov0" title="0">return cmd.CombinedOutput()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ai

import (
        "fmt"
        "reviewtask/internal/github"
        "strings"
)

// CommentChunker handles splitting large comments into manageable chunks
type CommentChunker struct {
        maxChunkSize int
}

// NewCommentChunker creates a new comment chunker
func NewCommentChunker(maxSize int) *CommentChunker <span class="cov8" title="1">{
        if maxSize &lt;= 0 </span><span class="cov0" title="0">{
                maxSize = 10000 // Default to 10KB chunks
        }</span>
        <span class="cov8" title="1">return &amp;CommentChunker{
                maxChunkSize: maxSize,
        }</span>
}

// ChunkComment splits a large comment into smaller chunks if needed
func (c *CommentChunker) ChunkComment(comment github.Comment) []github.Comment <span class="cov8" title="1">{
        if len(comment.Body) &lt;= c.maxChunkSize </span><span class="cov8" title="1">{
                return []github.Comment{comment}
        }</span>

        // Split the comment body into chunks
        <span class="cov8" title="1">chunks := c.splitIntoChunks(comment.Body)
        result := make([]github.Comment, len(chunks))

        for i, chunk := range chunks </span><span class="cov8" title="1">{
                result[i] = github.Comment{
                        ID:        comment.ID,
                        File:      comment.File,
                        Line:      comment.Line,
                        Body:      chunk,
                        Author:    comment.Author,
                        CreatedAt: comment.CreatedAt,
                        Replies:   comment.Replies, // Include replies only in first chunk
                }

                // Add chunk indicator
                if len(chunks) &gt; 1 </span><span class="cov8" title="1">{
                        result[i].Body = fmt.Sprintf("[Part %d/%d]\n%s", i+1, len(chunks), chunk)
                }</span>

                // Only include replies in the first chunk
                <span class="cov8" title="1">if i &gt; 0 </span><span class="cov8" title="1">{
                        result[i].Replies = nil
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// splitIntoChunks splits text into chunks at sentence boundaries when possible
func (c *CommentChunker) splitIntoChunks(text string) []string <span class="cov8" title="1">{
        if len(text) &lt;= c.maxChunkSize </span><span class="cov8" title="1">{
                return []string{text}
        }</span>

        <span class="cov8" title="1">var chunks []string
        remaining := text

        for len(remaining) &gt; 0 </span><span class="cov8" title="1">{
                if len(remaining) &lt;= c.maxChunkSize </span><span class="cov8" title="1">{
                        chunks = append(chunks, remaining)
                        break</span>
                }

                // Try to find a good break point (sentence end, paragraph, etc.)
                <span class="cov8" title="1">chunkEnd := c.findBreakPoint(remaining, c.maxChunkSize)

                chunk := strings.TrimSpace(remaining[:chunkEnd])
                chunks = append(chunks, chunk)
                remaining = strings.TrimSpace(remaining[chunkEnd:])</span>
        }

        <span class="cov8" title="1">return chunks</span>
}

// findBreakPoint finds a good point to break the text
func (c *CommentChunker) findBreakPoint(text string, maxPos int) int <span class="cov8" title="1">{
        if maxPos &gt;= len(text) </span><span class="cov0" title="0">{
                return len(text)
        }</span>

        // Look for sentence endings first
        <span class="cov8" title="1">sentenceEnds := []string{". ", ".\n", "! ", "!\n", "? ", "?\n"}
        bestPos := c.findLastOccurrence(text[:maxPos], sentenceEnds)
        if bestPos &gt; maxPos/2 </span><span class="cov8" title="1">{ // If we found a sentence end in the second half
                return bestPos + 1
        }</span>

        // Look for paragraph breaks
        <span class="cov8" title="1">paragraphBreaks := []string{"\n\n", "\n-", "\n*", "\n1.", "\n2.", "\n3."}
        bestPos = c.findLastOccurrence(text[:maxPos], paragraphBreaks)
        if bestPos &gt; maxPos/2 </span><span class="cov8" title="1">{
                return bestPos + 1
        }</span>

        // Look for any newline
        <span class="cov0" title="0">newlinePos := strings.LastIndex(text[:maxPos], "\n")
        if newlinePos &gt; maxPos/2 </span><span class="cov0" title="0">{
                return newlinePos + 1
        }</span>

        // Look for word boundaries
        <span class="cov0" title="0">spacePos := strings.LastIndex(text[:maxPos], " ")
        if spacePos &gt; 0 </span><span class="cov0" title="0">{
                return spacePos + 1
        }</span>

        // Fallback: just cut at maxPos
        <span class="cov0" title="0">return maxPos</span>
}

// findLastOccurrence finds the last occurrence of any delimiter
func (c *CommentChunker) findLastOccurrence(text string, delimiters []string) int <span class="cov8" title="1">{
        bestPos := -1
        for _, delim := range delimiters </span><span class="cov8" title="1">{
                pos := strings.LastIndex(text, delim)
                if pos &gt; bestPos </span><span class="cov8" title="1">{
                        bestPos = pos
                }</span>
        }
        <span class="cov8" title="1">return bestPos</span>
}

// ShouldChunkComment determines if a comment needs chunking
func (c *CommentChunker) ShouldChunkComment(comment github.Comment) bool <span class="cov8" title="1">{
        // Check if the comment body alone exceeds the chunk size
        return len(comment.Body) &gt; c.maxChunkSize
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package ai

import (
        "fmt"
        "regexp"
        "strings"

        "reviewtask/internal/github"
)

// ContentSummarizer handles automatic summarization of large comments
type ContentSummarizer struct {
        maxSize     int
        verboseMode bool
}

// NewContentSummarizer creates a new content summarizer
func NewContentSummarizer(maxSize int, verboseMode bool) *ContentSummarizer <span class="cov8" title="1">{
        if maxSize &lt;= 0 </span><span class="cov8" title="1">{
                maxSize = 20000 // Default to 20KB before summarization
        }</span>
        <span class="cov8" title="1">return &amp;ContentSummarizer{
                maxSize:     maxSize,
                verboseMode: verboseMode,
        }</span>
}

// ShouldSummarize checks if a comment needs summarization
func (cs *ContentSummarizer) ShouldSummarize(comment github.Comment) bool <span class="cov8" title="1">{
        return len(comment.Body) &gt; cs.maxSize
}</span>

// SummarizeComment creates a summarized version of a large comment
func (cs *ContentSummarizer) SummarizeComment(comment github.Comment) github.Comment <span class="cov8" title="1">{
        if !cs.ShouldSummarize(comment) </span><span class="cov8" title="1">{
                return comment
        }</span>

        <span class="cov8" title="1">if cs.verboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  📝 Summarizing comment %d (size: %d -&gt; target: %d bytes)\n",
                        comment.ID, len(comment.Body), cs.maxSize)
        }</span>

        <span class="cov8" title="1">summarizedBody := cs.createSummary(comment.Body)

        // Create summarized comment
        summarized := comment
        summarized.Body = summarizedBody

        if cs.verboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  ✅ Summary created (size: %d bytes, reduction: %.1f%%)\n",
                        len(summarizedBody),
                        100.0*(1.0-float64(len(summarizedBody))/float64(len(comment.Body))))
        }</span>

        <span class="cov8" title="1">return summarized</span>
}

// createSummary generates an intelligent summary of the comment content
func (cs *ContentSummarizer) createSummary(content string) string <span class="cov8" title="1">{
        // Start with the original content
        lines := strings.Split(content, "\n")

        // Extract the most important information
        summary := cs.extractKeyInformation(lines)

        // If still too large, apply aggressive summarization
        if len(summary) &gt; cs.maxSize </span><span class="cov0" title="0">{
                summary = cs.applyAggressiveSummarization(summary)
        }</span>

        // Add summary indicator
        <span class="cov8" title="1">header := fmt.Sprintf("[SUMMARIZED: Original %d bytes, Summary %d bytes]\n\n",
                len(content), len(summary))

        return header + summary</span>
}

// extractKeyInformation extracts the most relevant parts of the comment
func (cs *ContentSummarizer) extractKeyInformation(lines []string) string <span class="cov8" title="1">{
        var keyLines []string
        var codeBlocks []string
        var issues []string
        var suggestions []string

        inCodeBlock := false
        var currentCodeBlock []string

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)

                // Handle code blocks
                if strings.HasPrefix(line, "```") </span><span class="cov8" title="1">{
                        if inCodeBlock </span><span class="cov8" title="1">{
                                // End of code block
                                if len(currentCodeBlock) &gt; 0 </span><span class="cov8" title="1">{
                                        codeBlocks = append(codeBlocks, cs.summarizeCodeBlock(currentCodeBlock))
                                }</span>
                                <span class="cov8" title="1">currentCodeBlock = nil
                                inCodeBlock = false</span>
                        } else<span class="cov8" title="1"> {
                                // Start of code block
                                inCodeBlock = true
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if inCodeBlock </span><span class="cov8" title="1">{
                        currentCodeBlock = append(currentCodeBlock, line)
                        continue</span>
                }

                // Skip empty lines and very short lines
                <span class="cov8" title="1">if len(line) &lt; 3 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Categorize important content
                <span class="cov8" title="1">lowLine := strings.ToLower(line)

                // High priority patterns (always include)
                if cs.isHighPriorityLine(lowLine) </span><span class="cov8" title="1">{
                        keyLines = append(keyLines, line)
                        continue</span>
                }

                // Issues and problems
                <span class="cov8" title="1">if cs.isIssueLine(lowLine) </span><span class="cov0" title="0">{
                        issues = append(issues, line)
                        continue</span>
                }

                // Suggestions and recommendations
                <span class="cov8" title="1">if cs.isSuggestionLine(lowLine) </span><span class="cov8" title="1">{
                        suggestions = append(suggestions, line)
                        continue</span>
                }

                // Include other important-looking lines but limit them
                <span class="cov8" title="1">if cs.isImportantLine(lowLine) &amp;&amp; len(keyLines) &lt; 10 </span><span class="cov8" title="1">{
                        keyLines = append(keyLines, line)
                }</span>
        }

        // Compile summary sections
        <span class="cov8" title="1">var summaryParts []string

        if len(keyLines) &gt; 0 </span><span class="cov8" title="1">{
                summaryParts = append(summaryParts, "**Key Points:**\n"+strings.Join(keyLines, "\n"))
        }</span>

        <span class="cov8" title="1">if len(issues) &gt; 0 </span><span class="cov0" title="0">{
                summaryParts = append(summaryParts, "**Issues:**\n"+strings.Join(issues, "\n"))
        }</span>

        <span class="cov8" title="1">if len(suggestions) &gt; 0 </span><span class="cov8" title="1">{
                summaryParts = append(summaryParts, "**Suggestions:**\n"+strings.Join(suggestions, "\n"))
        }</span>

        <span class="cov8" title="1">if len(codeBlocks) &gt; 0 </span><span class="cov8" title="1">{
                summaryParts = append(summaryParts, "**Code Examples:**\n"+strings.Join(codeBlocks, "\n\n"))
        }</span>

        <span class="cov8" title="1">return strings.Join(summaryParts, "\n\n")</span>
}

// applyAggressiveSummarization reduces content further if needed
func (cs *ContentSummarizer) applyAggressiveSummarization(content string) string <span class="cov8" title="1">{
        lines := strings.Split(content, "\n")

        // Keep only the most critical information
        var criticalLines []string
        for _, line := range lines </span><span class="cov8" title="1">{
                if len(criticalLines)*50 &gt; cs.maxSize </span><span class="cov0" title="0">{ // Rough estimate
                        break</span>
                }

                <span class="cov8" title="1">line = strings.TrimSpace(line)
                lowLine := strings.ToLower(line)

                // Only keep critical information
                if cs.isCriticalLine(lowLine) </span><span class="cov0" title="0">{
                        criticalLines = append(criticalLines, line)
                }</span>
        }

        <span class="cov8" title="1">if len(criticalLines) == 0 </span><span class="cov8" title="1">{
                // Last resort: take first meaningful lines
                for i, line := range lines </span><span class="cov8" title="1">{
                        if i &gt;= 20 </span><span class="cov0" title="0">{ // Limit to first 20 lines
                                break</span>
                        }
                        <span class="cov8" title="1">line = strings.TrimSpace(line)
                        if len(line) &gt; 5 &amp;&amp; !strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                                criticalLines = append(criticalLines, line)
                        }</span>
                }
        }

        <span class="cov8" title="1">result := strings.Join(criticalLines, "\n")
        if len(result) &gt; cs.maxSize </span><span class="cov8" title="1">{
                // Ultimate truncation
                result = result[:cs.maxSize-20] + "\n\n[TRUNCATED...]"
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Helper methods for content classification

func (cs *ContentSummarizer) isHighPriorityLine(line string) bool <span class="cov8" title="1">{
        highPriorityPatterns := []string{
                "security", "vulnerability", "critical", "urgent", "error", "bug",
                "failure", "broken", "crash", "memory leak", "performance",
                "todo:", "fixme:", "hack:", "warning:",
        }

        for _, pattern := range highPriorityPatterns </span><span class="cov8" title="1">{
                if strings.Contains(line, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (cs *ContentSummarizer) isIssueLine(line string) bool <span class="cov8" title="1">{
        issuePatterns := []string{
                "issue:", "problem:", "incorrect", "wrong", "missing", "fail",
                "doesn't work", "not working", "broken", "error in",
        }

        for _, pattern := range issuePatterns </span><span class="cov8" title="1">{
                if strings.Contains(line, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (cs *ContentSummarizer) isSuggestionLine(line string) bool <span class="cov8" title="1">{
        suggestionPatterns := []string{
                "suggest", "recommend", "should", "could", "might want to",
                "consider", "perhaps", "maybe", "improvement", "better",
        }

        for _, pattern := range suggestionPatterns </span><span class="cov8" title="1">{
                if strings.Contains(line, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (cs *ContentSummarizer) isImportantLine(line string) bool <span class="cov8" title="1">{
        // Lines that are likely to be important
        if len(line) &lt; 10 || len(line) &gt; 200 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Contains keywords that suggest importance
        <span class="cov8" title="1">importantKeywords := []string{
                "important", "note", "remember", "key", "main", "primary",
                "essential", "required", "necessary", "must", "need",
        }

        for _, keyword := range importantKeywords </span><span class="cov8" title="1">{
                if strings.Contains(line, keyword) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Bullet points or numbered lists
        <span class="cov8" title="1">if regexp.MustCompile(`^\s*[*\-+•]\s`).MatchString(line) ||
                regexp.MustCompile(`^\s*\d+[.)]\s`).MatchString(line) </span><span class="cov8" title="1">{
                return true
        }</span>

        // Questions
        <span class="cov8" title="1">if strings.HasSuffix(line, "?") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func (cs *ContentSummarizer) isCriticalLine(line string) bool <span class="cov8" title="1">{
        return cs.isHighPriorityLine(line) || cs.isIssueLine(line)
}</span>

func (cs *ContentSummarizer) summarizeCodeBlock(lines []string) string <span class="cov8" title="1">{
        if len(lines) &lt;= 5 </span><span class="cov8" title="1">{
                // Short code block, include as-is
                return "```\n" + strings.Join(lines, "\n") + "\n```"
        }</span>

        // For longer blocks, show first few lines and summary
        <span class="cov8" title="1">preview := lines[:3]
        summary := fmt.Sprintf("[Code block with %d lines - showing first 3]\n```\n%s\n...\n```",
                len(lines), strings.Join(preview, "\n"))

        return summary</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package ai

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// EnhancedJSONRecovery provides advanced JSON repair capabilities
type EnhancedJSONRecovery struct {
        verboseMode bool
        config      *JSONRecoveryConfig
}

// NewEnhancedJSONRecovery creates an enhanced JSON recovery system
func NewEnhancedJSONRecovery(enableRecovery bool, verboseMode bool) *EnhancedJSONRecovery <span class="cov8" title="1">{
        return &amp;EnhancedJSONRecovery{
                verboseMode: verboseMode,
                config: &amp;JSONRecoveryConfig{
                        EnableRecovery:        enableRecovery,
                        MaxRecoveryAttempts:   5,   // Increased for enhanced recovery
                        PartialThreshold:      0.6, // Lower threshold for more aggressive recovery
                        LogTruncatedResponses: true,
                },
        }
}</span>

// RepairAndRecover attempts to repair JSON structure and recover tasks
func (ejr *EnhancedJSONRecovery) RepairAndRecover(rawResponse string, originalError error) *JSONRecoveryResult <span class="cov8" title="1">{
        result := &amp;JSONRecoveryResult{
                IsRecovered:   false,
                Tasks:         []TaskRequest{},
                ErrorType:     ejr.categorizeError(originalError),
                Message:       originalError.Error(),
                OriginalSize:  len(rawResponse),
                RecoveredSize: 0,
        }

        if !ejr.config.EnableRecovery </span><span class="cov8" title="1">{
                result.Message = "Enhanced JSON recovery disabled"
                return result
        }</span>

        <span class="cov8" title="1">if ejr.verboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  🔧 Enhanced JSON recovery for %s error (size: %d bytes)\n",
                        result.ErrorType, result.OriginalSize)
        }</span>

        // Enhanced recovery strategies
        <span class="cov8" title="1">strategies := []func(string, *JSONRecoveryResult) *JSONRecoveryResult{
                ejr.repairStructuralIssues,
                ejr.completeTruncatedJSON,
                ejr.extractPartialStructures,
                ejr.reconstructFromFragments,
                ejr.intelligentFieldCompletion,
        }

        for i, strategy := range strategies </span><span class="cov8" title="1">{
                if ejr.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    🎯 Trying strategy %d...\n", i+1)
                }</span>

                <span class="cov8" title="1">attemptResult := strategy(rawResponse, result)
                if attemptResult.IsRecovered &amp;&amp; len(attemptResult.Tasks) &gt; 0 </span><span class="cov8" title="1">{
                        if ejr.verboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("    ✅ Strategy %d successful: recovered %d tasks\n", i+1, len(attemptResult.Tasks))
                        }</span>
                        <span class="cov8" title="1">return attemptResult</span>
                }
        }

        <span class="cov8" title="1">if ejr.verboseMode </span><span class="cov0" title="0">{
                fmt.Printf("    ❌ All enhanced recovery strategies failed\n")
        }</span>

        <span class="cov8" title="1">return result</span>
}

// repairStructuralIssues fixes common JSON structural problems
func (ejr *EnhancedJSONRecovery) repairStructuralIssues(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov8" title="1">{
        repaired := response

        // Fix common structural issues
        fixes := []struct {
                pattern     string
                replacement string
                description string
        }{
                {`}\s*{`, `}, {`, "Fix missing comma between objects"},
                {`"\s*:\s*"([^"]*)"([^,}\]])`, `": "$1"$2`, "Fix unterminated string values"},
                {`]\s*\[`, `], [`, "Fix missing comma between arrays"},
                {`([^,\[\{])\s*"`, `$1, "`, "Add missing comma before quote"},
                {`([^,\[\{])\s*\{`, `$1, {`, "Add missing comma before object"},
                {`}\s*]$`, `}]`, "Remove trailing whitespace before array end"},
                {`^\s*\[?\s*`, `[`, "Ensure array starts properly"},
                {`\s*\]?\s*$`, `]`, "Ensure array ends properly"},
        }

        for _, fix := range fixes </span><span class="cov8" title="1">{
                re := regexp.MustCompile(fix.pattern)
                if re.MatchString(repaired) </span><span class="cov8" title="1">{
                        oldRepaired := repaired
                        repaired = re.ReplaceAllString(repaired, fix.replacement)
                        if ejr.verboseMode &amp;&amp; repaired != oldRepaired </span><span class="cov0" title="0">{
                                fmt.Printf("      🔧 Applied fix: %s\n", fix.description)
                        }</span>
                }
        }

        // Try to parse repaired JSON
        <span class="cov8" title="1">if tasks := ejr.tryParseJSON(repaired); tasks != nil </span><span class="cov0" title="0">{
                result.IsRecovered = true
                result.Tasks = tasks
                result.RecoveredSize = len(repaired)
                result.Message = "Repaired structural JSON issues"
                return result
        }</span>

        <span class="cov8" title="1">return result</span>
}

// completeTruncatedJSON attempts to complete truncated JSON
func (ejr *EnhancedJSONRecovery) completeTruncatedJSON(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov8" title="1">{
        // Find the last complete object or partial object
        lastBraceIndex := strings.LastIndex(response, "{")
        if lastBraceIndex == -1 </span><span class="cov8" title="1">{
                return result
        }</span>

        // Try to complete the truncated object
        <span class="cov8" title="1">truncatedPart := response[lastBraceIndex:]

        // Add minimal completion to make it parseable
        completionStrategies := []string{
                truncatedPart + `}]`,                                          // Simple object end
                truncatedPart + `", "priority": "medium"}]`,                   // Complete common field
                truncatedPart + `", "priority": "medium", "status": "todo"}]`, // Complete with defaults
        }

        for _, completed := range completionStrategies </span><span class="cov8" title="1">{
                fullResponse := response[:lastBraceIndex] + completed
                if tasks := ejr.tryParseJSON(fullResponse); tasks != nil </span><span class="cov8" title="1">{
                        result.IsRecovered = true
                        result.Tasks = tasks
                        result.RecoveredSize = len(fullResponse)
                        result.Message = "Completed truncated JSON structure"
                        if ejr.verboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("      ✅ Completed with strategy: %s\n", completed[len(truncatedPart):])
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// extractPartialStructures extracts valid structures from malformed JSON
func (ejr *EnhancedJSONRecovery) extractPartialStructures(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov8" title="1">{
        // Use regex to find task-like structures
        taskPattern := regexp.MustCompile(`\{\s*"[^"]*description[^"]*"\s*:\s*"([^"]*)"[^}]*\}`)
        matches := taskPattern.FindAllString(response, -1)

        var recoveredTasks []TaskRequest

        for _, match := range matches </span><span class="cov8" title="1">{
                // Try to extract and complete partial task structures
                if task := ejr.parsePartialTask(match); task != nil </span><span class="cov8" title="1">{
                        recoveredTasks = append(recoveredTasks, *task)
                }</span>
        }

        <span class="cov8" title="1">if len(recoveredTasks) &gt; 0 </span><span class="cov8" title="1">{
                result.IsRecovered = true
                result.Tasks = recoveredTasks
                result.RecoveredSize = len(response)
                result.Message = fmt.Sprintf("Extracted %d partial task structures", len(recoveredTasks))
                return result
        }</span>

        <span class="cov8" title="1">return result</span>
}

// reconstructFromFragments attempts to reconstruct JSON from fragments
func (ejr *EnhancedJSONRecovery) reconstructFromFragments(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov8" title="1">{
        // Find all string values that look like descriptions
        descPattern := regexp.MustCompile(`"([^"]{20,})"`)
        descriptions := descPattern.FindAllStringSubmatch(response, -1)

        if len(descriptions) == 0 </span><span class="cov8" title="1">{
                return result
        }</span>

        <span class="cov8" title="1">var reconstructedTasks []TaskRequest
        for _, desc := range descriptions </span><span class="cov8" title="1">{
                if len(desc) &gt; 1 &amp;&amp; ejr.looksLikeTaskDescription(desc[1]) </span><span class="cov8" title="1">{
                        task := TaskRequest{
                                Description: desc[1],
                                Priority:    "medium", // Default priority
                                Status:      "todo",   // Default status
                        }
                        reconstructedTasks = append(reconstructedTasks, task)
                }</span>
        }

        <span class="cov8" title="1">if len(reconstructedTasks) &gt; 0 </span><span class="cov8" title="1">{
                result.IsRecovered = true
                result.Tasks = reconstructedTasks
                result.RecoveredSize = len(response)
                result.Message = fmt.Sprintf("Reconstructed %d tasks from fragments", len(reconstructedTasks))
                return result
        }</span>

        <span class="cov0" title="0">return result</span>
}

// intelligentFieldCompletion completes missing fields with intelligent defaults
func (ejr *EnhancedJSONRecovery) intelligentFieldCompletion(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov8" title="1">{
        // Try to find incomplete JSON objects and complete them
        objPattern := regexp.MustCompile(`\{[^}]*"description"\s*:\s*"([^"]*)"[^}]*`)
        matches := objPattern.FindAllString(response, -1)

        var completedObjects []string
        for _, match := range matches </span><span class="cov0" title="0">{
                completed := ejr.completeTaskObject(match)
                if completed != "" </span><span class="cov0" title="0">{
                        completedObjects = append(completedObjects, completed)
                }</span>
        }

        <span class="cov8" title="1">if len(completedObjects) &gt; 0 </span><span class="cov0" title="0">{
                // Construct a valid JSON array
                jsonArray := "[" + strings.Join(completedObjects, ", ") + "]"
                if tasks := ejr.tryParseJSON(jsonArray); tasks != nil </span><span class="cov0" title="0">{
                        result.IsRecovered = true
                        result.Tasks = tasks
                        result.RecoveredSize = len(jsonArray)
                        result.Message = fmt.Sprintf("Completed %d incomplete objects", len(tasks))
                        return result
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// Helper methods

func (ejr *EnhancedJSONRecovery) tryParseJSON(jsonStr string) []TaskRequest <span class="cov8" title="1">{
        var tasks []TaskRequest
        if err := json.Unmarshal([]byte(jsonStr), &amp;tasks); err == nil </span><span class="cov8" title="1">{
                return tasks
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ejr *EnhancedJSONRecovery) parsePartialTask(jsonStr string) *TaskRequest <span class="cov8" title="1">{
        // Try to parse as a complete task first
        var task TaskRequest
        if err := json.Unmarshal([]byte(jsonStr), &amp;task); err == nil </span><span class="cov8" title="1">{
                // Fill in missing required fields
                if task.Priority == "" </span><span class="cov8" title="1">{
                        task.Priority = "medium"
                }</span>
                <span class="cov8" title="1">if task.Status == "" </span><span class="cov8" title="1">{
                        task.Status = "todo"
                }</span>
                <span class="cov8" title="1">return &amp;task</span>
        }

        // Try to extract description manually and create minimal task
        <span class="cov8" title="1">descPattern := regexp.MustCompile(`"description"\s*:\s*"([^"]*)"`)
        if match := descPattern.FindStringSubmatch(jsonStr); len(match) &gt; 1 </span><span class="cov8" title="1">{
                return &amp;TaskRequest{
                        Description: match[1],
                        Priority:    "medium",
                        Status:      "todo",
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (ejr *EnhancedJSONRecovery) looksLikeTaskDescription(text string) bool <span class="cov8" title="1">{
        // Simple heuristics to identify task descriptions
        taskKeywords := []string{"fix", "add", "update", "remove", "change", "implement", "check"}
        lowText := strings.ToLower(text)

        for _, keyword := range taskKeywords </span><span class="cov8" title="1">{
                if strings.Contains(lowText, keyword) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Also accept if it's a reasonable length and contains common patterns
        <span class="cov8" title="1">return len(text) &gt; 10 &amp;&amp; len(text) &lt; 500</span>
}

func (ejr *EnhancedJSONRecovery) completeTaskObject(partialObj string) string <span class="cov0" title="0">{
        // Ensure the object has all required fields
        required := []string{"description", "priority", "status"}
        defaults := map[string]string{
                "priority": "medium",
                "status":   "todo",
        }

        // Start with the partial object, removing incomplete braces
        obj := strings.TrimSpace(partialObj)
        if !strings.HasPrefix(obj, "{") </span><span class="cov0" title="0">{
                obj = "{" + obj
        }</span>
        <span class="cov0" title="0">if !strings.HasSuffix(obj, "}") </span><span class="cov0" title="0">{
                obj = strings.TrimSuffix(obj, ",") + "}"
        }</span>

        // Try to parse to see what's missing
        <span class="cov0" title="0">var taskMap map[string]interface{}
        if err := json.Unmarshal([]byte(obj), &amp;taskMap); err == nil </span><span class="cov0" title="0">{
                // Add missing fields
                for _, field := range required </span><span class="cov0" title="0">{
                        if _, exists := taskMap[field]; !exists </span><span class="cov0" title="0">{
                                if defaultVal, hasDefault := defaults[field]; hasDefault </span><span class="cov0" title="0">{
                                        taskMap[field] = defaultVal
                                }</span>
                        }
                }

                // Convert back to JSON
                <span class="cov0" title="0">if completed, err := json.Marshal(taskMap); err == nil </span><span class="cov0" title="0">{
                        return string(completed)
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (ejr *EnhancedJSONRecovery) categorizeError(err error) string <span class="cov8" title="1">{
        errMsg := strings.ToLower(err.Error())

        if strings.Contains(errMsg, "unexpected end of json input") ||
                strings.Contains(errMsg, "unexpected end of input") </span><span class="cov8" title="1">{
                return "truncation"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "invalid character") ||
                strings.Contains(errMsg, "looking for beginning of object") </span><span class="cov8" title="1">{
                return "malformed"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "cannot unmarshal") </span><span class="cov8" title="1">{
                return "type_mismatch"
        }</span>

        <span class="cov8" title="1">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package ai

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"
)

// CommentError represents an error that occurred while processing a comment
type CommentError struct {
        CommentID    int64     `json:"comment_id"`
        CommentBody  string    `json:"comment_body"` // First 500 chars for context
        SourceReview int64     `json:"source_review_id"`
        File         string    `json:"file"`
        Line         int       `json:"line"`
        Author       string    `json:"author"`
        ErrorType    string    `json:"error_type"` // "json_parse", "api_failure", "context_overflow", "timeout"
        ErrorMessage string    `json:"error_message"`
        RetryCount   int       `json:"retry_count"`
        Timestamp    time.Time `json:"timestamp"`
        RecoveryUsed bool      `json:"recovery_used"`           // Whether JSON recovery was attempted
        PromptSize   int       `json:"prompt_size,omitempty"`   // Size of prompt that caused the error
        ResponseSize int       `json:"response_size,omitempty"` // Size of response received
}

// ErrorTracker manages error logging for comment processing failures
type ErrorTracker struct {
        enabled     bool
        verboseMode bool
        errorFile   string
}

// NewErrorTracker creates a new error tracker
func NewErrorTracker(enabled, verboseMode bool, storageDir string) *ErrorTracker <span class="cov8" title="1">{
        if storageDir == "" </span><span class="cov8" title="1">{
                storageDir = ".pr-review"
        }</span>

        <span class="cov8" title="1">return &amp;ErrorTracker{
                enabled:     enabled,
                verboseMode: verboseMode,
                errorFile:   filepath.Join(storageDir, "errors.json"),
        }</span>
}

// RecordCommentError records an error that occurred during comment processing
func (et *ErrorTracker) RecordCommentError(commentCtx CommentContext, errorType, errorMessage string, retryCount int, recoveryUsed bool, promptSize, responseSize int) <span class="cov8" title="1">{
        if !et.enabled </span><span class="cov8" title="1">{
                return
        }</span>

        // Truncate comment body for storage (keep first 500 chars)
        <span class="cov8" title="1">commentBody := commentCtx.Comment.Body
        if len(commentBody) &gt; 500 </span><span class="cov8" title="1">{
                commentBody = commentBody[:500] + "..."
        }</span>

        <span class="cov8" title="1">commentError := CommentError{
                CommentID:    commentCtx.Comment.ID,
                CommentBody:  commentBody,
                SourceReview: commentCtx.SourceReview.ID,
                File:         commentCtx.Comment.File,
                Line:         commentCtx.Comment.Line,
                Author:       commentCtx.Comment.Author,
                ErrorType:    errorType,
                ErrorMessage: errorMessage,
                RetryCount:   retryCount,
                Timestamp:    time.Now(),
                RecoveryUsed: recoveryUsed,
                PromptSize:   promptSize,
                ResponseSize: responseSize,
        }

        et.appendError(commentError)

        if et.verboseMode </span><span class="cov8" title="1">{
                fmt.Printf("  ❌ Error recorded for comment %d: %s (%s)\n",
                        commentError.CommentID, errorType, errorMessage)
        }</span>
}

// GetErrorSummary returns a summary of recent errors
func (et *ErrorTracker) GetErrorSummary() ([]CommentError, error) <span class="cov8" title="1">{
        if !et.enabled </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return et.readErrors()</span>
}

// ClearErrors removes all recorded errors (typically after successful resolution)
func (et *ErrorTracker) ClearErrors() error <span class="cov8" title="1">{
        if !et.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Remove the error file
        <span class="cov8" title="1">if _, err := os.Stat(et.errorFile); err == nil </span><span class="cov8" title="1">{
                return os.Remove(et.errorFile)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetErrorCount returns the number of errors recorded
func (et *ErrorTracker) GetErrorCount() int <span class="cov8" title="1">{
        errors, err := et.GetErrorSummary()
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return len(errors)</span>
}

// appendError adds an error to the error file
func (et *ErrorTracker) appendError(commentError CommentError) <span class="cov8" title="1">{
        // Read existing errors
        errors, _ := et.readErrors() // Ignore read errors, start fresh if needed

        // Add new error
        errors = append(errors, commentError)

        // Keep only recent errors (last 100) to prevent file from growing too large
        if len(errors) &gt; 100 </span><span class="cov8" title="1">{
                errors = errors[len(errors)-100:]
        }</span>

        // Write back to file
        <span class="cov8" title="1">et.writeErrors(errors)</span>
}

// readErrors reads all errors from the error file
func (et *ErrorTracker) readErrors() ([]CommentError, error) <span class="cov8" title="1">{
        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(et.errorFile), 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create error directory: %w", err)
        }</span>

        // Check if file exists
        <span class="cov8" title="1">if _, err := os.Stat(et.errorFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []CommentError{}, nil
        }</span>

        // Read file
        <span class="cov8" title="1">data, err := os.ReadFile(et.errorFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read error file: %w", err)
        }</span>

        <span class="cov8" title="1">var errors []CommentError
        if err := json.Unmarshal(data, &amp;errors); err != nil </span><span class="cov8" title="1">{
                // If JSON is corrupted, start fresh
                if et.verboseMode </span><span class="cov8" title="1">{
                        fmt.Printf("  ⚠️  Error file corrupted, starting fresh: %v\n", err)
                }</span>
                <span class="cov8" title="1">return []CommentError{}, nil</span>
        }

        <span class="cov8" title="1">return errors, nil</span>
}

// writeErrors writes errors to the error file
func (et *ErrorTracker) writeErrors(errors []CommentError) <span class="cov8" title="1">{
        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(et.errorFile), 0755); err != nil </span><span class="cov0" title="0">{
                if et.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  ⚠️  Failed to create error directory: %v\n", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Marshal to JSON with indentation for readability
        <span class="cov8" title="1">data, err := json.MarshalIndent(errors, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                if et.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  ⚠️  Failed to marshal errors: %v\n", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(et.errorFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                if et.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  ⚠️  Failed to write error file: %v\n", err)
                }</span>
        }
}

// PrintErrorSummary prints a summary of errors to console
func (et *ErrorTracker) PrintErrorSummary() <span class="cov8" title="1">{
        if !et.enabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">errors, err := et.GetErrorSummary()
        if err != nil </span><span class="cov0" title="0">{
                if et.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  ⚠️  Failed to read error summary: %v\n", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">if len(errors) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">fmt.Printf("\n📊 Error Summary (%d errors recorded):\n", len(errors))

        // Count by error type
        errorTypes := make(map[string]int)
        for _, e := range errors </span><span class="cov8" title="1">{
                errorTypes[e.ErrorType]++
        }</span>

        <span class="cov8" title="1">for errorType, count := range errorTypes </span><span class="cov8" title="1">{
                fmt.Printf("  • %s: %d errors\n", errorType, count)
        }</span>

        // Show most recent errors
        <span class="cov8" title="1">recentCount := 3
        if len(errors) &lt; recentCount </span><span class="cov8" title="1">{
                recentCount = len(errors)
        }</span>

        <span class="cov8" title="1">fmt.Printf("\nMost recent errors:\n")
        for i := len(errors) - recentCount; i &lt; len(errors); i++ </span><span class="cov8" title="1">{
                e := errors[i]
                fmt.Printf("  • Comment %d (%s): %s\n", e.CommentID, e.ErrorType, e.ErrorMessage)
        }</span>

        <span class="cov8" title="1">fmt.Printf("\nFor full details, see: %s\n", et.errorFile)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package ai

import (
        "errors"
        "fmt"
        "strings"
)

// Critical error types that should stop processing
var (
        // ErrClaudeAPI indicates a Claude API related error
        ErrClaudeAPI = errors.New("claude API error")

        // ErrAuthentication indicates an authentication failure
        ErrAuthentication = errors.New("authentication error")

        // ErrCritical is a generic critical error
        ErrCritical = errors.New("critical error")
)

// ClaudeAPIError represents a Claude API specific error
type ClaudeAPIError struct {
        Message string
        Err     error
}

func (e *ClaudeAPIError) Error() string <span class="cov8" title="1">{
        if e.Err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("claude API error: %s: %v", e.Message, e.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("claude API error: %s", e.Message)</span>
}

func (e *ClaudeAPIError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// AuthenticationError represents an authentication failure
type AuthenticationError struct {
        Source  string
        Message string
        Err     error
}

func (e *AuthenticationError) Error() string <span class="cov0" title="0">{
        if e.Err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("authentication error (%s): %s: %v", e.Source, e.Message, e.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("authentication error (%s): %s", e.Source, e.Message)</span>
}

func (e *AuthenticationError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// NewClaudeAPIError creates a new Claude API error
func NewClaudeAPIError(message string, err error) error <span class="cov8" title="1">{
        return &amp;ClaudeAPIError{
                Message: message,
                Err:     err,
        }
}</span>

// NewAuthenticationError creates a new authentication error
func NewAuthenticationError(source, message string, err error) error <span class="cov0" title="0">{
        return &amp;AuthenticationError{
                Source:  source,
                Message: message,
                Err:     err,
        }
}</span>

// isCriticalError determines if an error is critical and should stop processing
func isCriticalError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for specific error types
        <span class="cov8" title="1">var claudeErr *ClaudeAPIError
        var authErr *AuthenticationError

        if errors.As(err, &amp;claudeErr) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if errors.As(err, &amp;authErr) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for wrapped sentinel errors
        <span class="cov8" title="1">if errors.Is(err, ErrClaudeAPI) || errors.Is(err, ErrAuthentication) || errors.Is(err, ErrCritical) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Fallback to string matching for legacy errors
        // This can be removed once all errors are properly typed
        <span class="cov8" title="1">errStr := err.Error()
        return strings.Contains(errStr, "claude") || strings.Contains(errStr, "authentication")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package ai

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "reviewtask/internal/github"
        "reviewtask/internal/storage"
)

// IncrementalOptions contains options for incremental processing
type IncrementalOptions struct {
        BatchSize       int
        Resume          bool
        FastMode        bool
        MaxTimeout      time.Duration
        ShowProgress    bool
        OnProgress      func(processed, total int)
        OnBatchComplete func(batchTasks []storage.Task)
}

// GenerateTasksIncremental processes reviews incrementally with checkpointing
func (a *Analyzer) GenerateTasksIncremental(reviews []github.Review, prNumber int, storageManager *storage.Manager, opts IncrementalOptions) ([]storage.Task, error) <span class="cov8" title="1">{
        // Clear validation feedback to ensure clean state
        a.clearValidationFeedback()

        if len(reviews) == 0 </span><span class="cov8" title="1">{
                return []storage.Task{}, nil
        }</span>

        // Extract all comments with filtering
        <span class="cov8" title="1">allComments := a.extractComments(reviews)
        if len(allComments) == 0 </span><span class="cov0" title="0">{
                return []storage.Task{}, nil
        }</span>

        // Load or create checkpoint
        <span class="cov8" title="1">checkpoint, err := a.loadOrCreateCheckpoint(prNumber, storageManager, allComments, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load checkpoint: %w", err)
        }</span>

        // Filter out already processed comments if resuming
        <span class="cov8" title="1">remainingComments := a.filterProcessedComments(allComments, checkpoint)

        if opts.ShowProgress &amp;&amp; checkpoint.ProcessedCount &gt; 0 &amp;&amp; a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  Resuming from checkpoint: %d/%d comments already processed\n", checkpoint.ProcessedCount, checkpoint.TotalComments)
        }</span>

        <span class="cov8" title="1">if len(remainingComments) == 0 </span><span class="cov0" title="0">{
                return checkpoint.PartialTasks, nil
        }</span>

        // Process in batches with timeout and checkpointing
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), opts.MaxTimeout)
        defer cancel()

        allTasks := append([]storage.Task{}, checkpoint.PartialTasks...)

        for i := 0; i &lt; len(remainingComments); i += opts.BatchSize </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // Save checkpoint before timeout
                        checkpoint.PartialTasks = allTasks
                        if err := storageManager.SaveCheckpoint(prNumber, checkpoint); err != nil </span><span class="cov0" title="0">{
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("⚠️  Failed to save checkpoint: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">return nil, fmt.Errorf("processing timed out after %v and failed to save checkpoint: %w", opts.MaxTimeout, err)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("processing timed out after %v. Use --resume to continue", opts.MaxTimeout)</span>
                default:<span class="cov8" title="1"></span>
                }

                // Calculate batch boundaries
                <span class="cov8" title="1">end := i + opts.BatchSize
                if end &gt; len(remainingComments) </span><span class="cov8" title="1">{
                        end = len(remainingComments)
                }</span>

                <span class="cov8" title="1">batch := remainingComments[i:end]

                // Show progress before processing batch
                if opts.OnProgress != nil &amp;&amp; opts.ShowProgress </span><span class="cov0" title="0">{
                        // Show progress for the batch we're about to process
                        startProgress := checkpoint.ProcessedCount
                        // Display progress for each comment in the batch
                        if len(batch) &gt; 0 </span><span class="cov0" title="0">{
                                opts.OnProgress(startProgress, checkpoint.TotalComments)
                        }</span>
                }

                // Process batch
                <span class="cov8" title="1">batchTasks, err := a.processBatch(batch, opts)
                if err != nil </span><span class="cov8" title="1">{
                        // Save checkpoint before continuing
                        checkpoint.PartialTasks = allTasks
                        if saveErr := storageManager.SaveCheckpoint(prNumber, checkpoint); saveErr != nil </span><span class="cov0" title="0">{
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("⚠️  Failed to save checkpoint: %v\n", saveErr)
                                }</span>
                                // For critical errors with checkpoint save failure, return both
                                <span class="cov0" title="0">if isCriticalError(err) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("critical error: %w, and failed to save checkpoint: %w", err, saveErr)
                                }</span>
                        }

                        // For critical errors, return immediately
                        <span class="cov8" title="1">if isCriticalError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("critical error: %w. Run 'reviewtask' again to resume from checkpoint", err)
                        }</span>

                        // For other errors, log and continue
                        <span class="cov8" title="1">if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  ⚠️  Some comments could not be processed: %v\n", err)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Update checkpoint
                <span class="cov8" title="1">for _, commentCtx := range batch </span><span class="cov8" title="1">{
                        checkpoint.ProcessedComments[commentCtx.Comment.ID] = a.calculateCommentHash(commentCtx.Comment)
                        checkpoint.ProcessedCount++
                }</span>

                <span class="cov8" title="1">allTasks = append(allTasks, batchTasks...)
                checkpoint.PartialTasks = allTasks

                // Save checkpoint after each batch
                if err := storageManager.SaveCheckpoint(prNumber, checkpoint); err != nil </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️  Failed to save checkpoint: %v\n", err)
                        }</span>
                }

                // Call progress callbacks
                <span class="cov8" title="1">if opts.OnProgress != nil </span><span class="cov8" title="1">{
                        opts.OnProgress(checkpoint.ProcessedCount, checkpoint.TotalComments)
                }</span>
                <span class="cov8" title="1">if opts.OnBatchComplete != nil </span><span class="cov8" title="1">{
                        opts.OnBatchComplete(batchTasks)
                }</span>

                // Add small delay to prevent API rate limiting
                <span class="cov8" title="1">if !opts.FastMode &amp;&amp; i+opts.BatchSize &lt; len(remainingComments) </span><span class="cov8" title="1">{
                        time.Sleep(500 * time.Millisecond)
                }</span>
        }

        // Delete checkpoint on successful completion
        <span class="cov8" title="1">if err := storageManager.DeleteCheckpoint(prNumber); err != nil </span><span class="cov0" title="0">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Failed to delete checkpoint: %v\n", err)
                }</span>
        }

        // Apply deduplication
        <span class="cov8" title="1">if a.config.AISettings.DeduplicationEnabled </span><span class="cov0" title="0">{
                deduped := a.deduplicateTasks(allTasks)
                if opts.ShowProgress &amp;&amp; len(deduped) &lt; len(allTasks) &amp;&amp; a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  AI deduplication: %d tasks → %d unique tasks\n",
                                len(allTasks), len(deduped))
                }</span>
                <span class="cov0" title="0">return deduped, nil</span>
        }

        <span class="cov8" title="1">return allTasks, nil</span>
}

// extractComments extracts all comments from reviews with filtering
func (a *Analyzer) extractComments(reviews []github.Review) []CommentContext <span class="cov8" title="1">{
        var allComments []CommentContext
        resolvedCommentCount := 0

        for _, review := range reviews </span><span class="cov8" title="1">{
                // Process review body as a comment if it exists
                if review.Body != "" </span><span class="cov8" title="1">{
                        reviewBodyComment := github.Comment{
                                ID:        review.ID,
                                File:      "",
                                Line:      0,
                                Body:      review.Body,
                                Author:    review.Reviewer,
                                CreatedAt: review.SubmittedAt,
                        }

                        if !a.isCommentResolved(reviewBodyComment) </span><span class="cov8" title="1">{
                                allComments = append(allComments, CommentContext{
                                        Comment:      reviewBodyComment,
                                        SourceReview: review,
                                })
                        }</span> else<span class="cov0" title="0"> {
                                resolvedCommentCount++
                        }</span>
                }

                // Process individual inline comments
                <span class="cov8" title="1">for _, comment := range review.Comments </span><span class="cov8" title="1">{
                        if a.isCommentResolved(comment) </span><span class="cov8" title="1">{
                                resolvedCommentCount++
                                continue</span>
                        }

                        <span class="cov8" title="1">allComments = append(allComments, CommentContext{
                                Comment:      comment,
                                SourceReview: review,
                        })</span>
                }
        }

        <span class="cov8" title="1">if resolvedCommentCount &gt; 0 </span><span class="cov8" title="1">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("📝 Filtered out %d resolved comments\n", resolvedCommentCount)
                }</span>
        }

        <span class="cov8" title="1">return allComments</span>
}

// loadOrCreateCheckpoint loads existing checkpoint or creates new one
func (a *Analyzer) loadOrCreateCheckpoint(prNumber int, storageManager *storage.Manager, comments []CommentContext, opts IncrementalOptions) (*storage.CheckpointState, error) <span class="cov8" title="1">{
        if opts.Resume </span><span class="cov8" title="1">{
                checkpoint, err := storageManager.LoadCheckpoint(prNumber)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if checkpoint != nil </span><span class="cov8" title="1">{
                        // Check if checkpoint is still valid (not too old)
                        if !storage.IsCheckpointStale(checkpoint, 24*time.Hour) </span><span class="cov8" title="1">{
                                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                        fmt.Printf("✅ Resuming from checkpoint (processed %d/%d comments)\n",
                                                checkpoint.ProcessedCount, checkpoint.TotalComments)
                                }</span>
                                <span class="cov8" title="1">return checkpoint, nil</span>
                        }
                        <span class="cov0" title="0">if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Println("⚠️  Checkpoint is too old, starting fresh")
                        }</span>
                }
        }

        // Create new checkpoint
        <span class="cov8" title="1">checkpoint := &amp;storage.CheckpointState{
                PRNumber:          prNumber,
                ProcessedComments: make(map[int64]string),
                StartedAt:         time.Now(),
                TotalComments:     len(comments),
                ProcessedCount:    0,
                BatchSize:         opts.BatchSize,
                PartialTasks:      []storage.Task{},
        }

        return checkpoint, nil</span>
}

// filterProcessedComments removes already processed comments based on checkpoint
func (a *Analyzer) filterProcessedComments(comments []CommentContext, checkpoint *storage.CheckpointState) []CommentContext <span class="cov8" title="1">{
        if len(checkpoint.ProcessedComments) == 0 </span><span class="cov8" title="1">{
                return comments
        }</span>

        <span class="cov8" title="1">var remaining []CommentContext
        for _, commentCtx := range comments </span><span class="cov8" title="1">{
                hash, exists := checkpoint.ProcessedComments[commentCtx.Comment.ID]
                currentHash := a.calculateCommentHash(commentCtx.Comment)

                // Include if not processed or if content changed
                if !exists || hash != currentHash </span><span class="cov8" title="1">{
                        remaining = append(remaining, commentCtx)
                }</span>
        }

        <span class="cov8" title="1">return remaining</span>
}

// processBatch processes a batch of comments with optimizations
func (a *Analyzer) processBatch(batch []CommentContext, opts IncrementalOptions) ([]storage.Task, error) <span class="cov8" title="1">{
        if len(batch) == 0 </span><span class="cov0" title="0">{
                return []storage.Task{}, nil
        }</span>

        // Use fast mode optimizations
        <span class="cov8" title="1">if opts.FastMode </span><span class="cov8" title="1">{
                // Process with reduced validation and simpler prompts
                return a.processBatchFastMode(batch)
        }</span>

        // Check if validation is enabled
        <span class="cov8" title="1">if a.config.AISettings.ValidationEnabled != nil &amp;&amp; *a.config.AISettings.ValidationEnabled </span><span class="cov0" title="0">{
                return a.processBatchWithValidation(batch)
        }</span>

        // Standard parallel processing
        <span class="cov8" title="1">return a.processBatchStandard(batch)</span>
}

// processBatchStandard processes batch with standard parallel processing
func (a *Analyzer) processBatchStandard(batch []CommentContext) ([]storage.Task, error) <span class="cov8" title="1">{
        type commentResult struct {
                tasks []TaskRequest
                err   error
                index int
        }

        results := make(chan commentResult, len(batch))
        var wg sync.WaitGroup

        // Process each comment in parallel
        for i, commentCtx := range batch </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(index int, ctx CommentContext) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        tasks, err := a.processComment(ctx)
                        results &lt;- commentResult{
                                tasks: tasks,
                                err:   err,
                                index: index,
                        }
                }</span>(i, commentCtx)
        }

        // Wait for all goroutines to complete
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(results)
        }</span>()

        // Collect results
        <span class="cov8" title="1">var allTasks []TaskRequest
        var errors []error

        for result := range results </span><span class="cov8" title="1">{
                if result.err != nil </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Errorf("comment %d: %w", result.index, result.err))
                }</span> else<span class="cov8" title="1"> {
                        allTasks = append(allTasks, result.tasks...)
                }</span>
        }

        // Report errors but continue if we have some successful results
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        for _, err := range errors </span><span class="cov0" title="0">{
                                fmt.Printf("  ⚠️  %v\n", err)
                        }</span>
                }
                <span class="cov8" title="1">if len(allTasks) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("all comment processing failed")
                }</span>
        }

        // Convert to storage tasks
        <span class="cov8" title="1">return a.convertToStorageTasks(allTasks), nil</span>
}

// processBatchWithValidation processes batch with validation enabled
func (a *Analyzer) processBatchWithValidation(batch []CommentContext) ([]storage.Task, error) <span class="cov0" title="0">{
        return a.processCommentsParallel(batch, a.processCommentWithValidation)
}</span>

// processBatchFastMode processes batch with fast mode optimizations
func (a *Analyzer) processBatchFastMode(batch []CommentContext) ([]storage.Task, error) <span class="cov8" title="1">{
        // In fast mode, we skip validation and use simpler prompts
        var allTasks []TaskRequest

        // Process comments with minimal overhead
        for _, commentCtx := range batch </span><span class="cov8" title="1">{
                // Skip very short comments in fast mode
                if len(commentCtx.Comment.Body) &lt; 20 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Use simplified prompt for speed
                <span class="cov8" title="1">prompt := a.buildFastModePrompt(commentCtx)
                tasks, err := a.callClaudeCode(prompt)
                if err != nil </span><span class="cov0" title="0">{
                        if a.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("  ⚠️  Fast mode processing error: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">allTasks = append(allTasks, tasks...)</span>
        }

        <span class="cov8" title="1">return a.convertToStorageTasks(allTasks), nil</span>
}

// buildFastModePrompt creates a simplified prompt for fast processing
func (a *Analyzer) buildFastModePrompt(ctx CommentContext) string <span class="cov8" title="1">{
        var languageInstruction string
        if a.config.AISettings.UserLanguage != "" </span><span class="cov8" title="1">{
                languageInstruction = fmt.Sprintf("Generate task descriptions in %s.\n", a.config.AISettings.UserLanguage)
        }</span>

        // Build example task using proper JSON marshaling
        <span class="cov8" title="1">exampleTask := map[string]interface{}{
                "description":       "Task description",
                "origin_text":       ctx.Comment.Body,
                "priority":          "medium", // Use neutral priority to avoid bias
                "source_review_id":  ctx.SourceReview.ID,
                "source_comment_id": ctx.Comment.ID,
                "file":              ctx.Comment.File,
                "line":              ctx.Comment.Line,
                "task_index":        0,
        }

        exampleJSON, err := json.MarshalIndent([]interface{}{exampleTask}, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple format if marshaling fails
                exampleJSON = []byte(`[{"description": "Task description", "origin_text": "...", "priority": "medium", "task_index": 0}]`)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(`Analyze this GitHub PR comment and generate actionable tasks.

%s

Comment: %s
File: %s:%d

Return JSON array:
%s

Only create tasks for actionable items. Return empty array [] if no action needed.`,
                languageInstruction,
                ctx.Comment.Body,
                ctx.Comment.File,
                ctx.Comment.Line,
                string(exampleJSON))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package ai

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// JSONRecoveryResult contains the result of JSON recovery attempt
type JSONRecoveryResult struct {
        IsRecovered   bool          `json:"is_recovered"`
        Tasks         []TaskRequest `json:"tasks"`
        ErrorType     string        `json:"error_type"`
        Message       string        `json:"message"`
        OriginalSize  int           `json:"original_size"`
        RecoveredSize int           `json:"recovered_size"`
}

// JSONRecoveryConfig contains configuration for JSON recovery
type JSONRecoveryConfig struct {
        EnableRecovery        bool    `json:"enable_recovery"`
        MaxRecoveryAttempts   int     `json:"max_recovery_attempts"`
        PartialThreshold      float64 `json:"partial_threshold"`
        LogTruncatedResponses bool    `json:"log_truncated_responses"`
}

// JSONRecoverer handles recovery of incomplete JSON responses
type JSONRecoverer struct {
        config      *JSONRecoveryConfig
        verboseMode bool
}

// NewJSONRecoverer creates a new JSON recovery handler
func NewJSONRecoverer(enableRecovery bool, verboseMode bool) *JSONRecoverer <span class="cov8" title="1">{
        return &amp;JSONRecoverer{
                config: &amp;JSONRecoveryConfig{
                        EnableRecovery:        enableRecovery,
                        MaxRecoveryAttempts:   3,
                        PartialThreshold:      0.7,
                        LogTruncatedResponses: true,
                },
                verboseMode: verboseMode,
        }
}</span>

// RecoverJSON attempts to recover valid tasks from incomplete JSON
func (jr *JSONRecoverer) RecoverJSON(rawResponse string, originalError error) *JSONRecoveryResult <span class="cov8" title="1">{
        result := &amp;JSONRecoveryResult{
                IsRecovered:   false,
                Tasks:         []TaskRequest{},
                ErrorType:     jr.categorizeError(originalError),
                Message:       originalError.Error(),
                OriginalSize:  len(rawResponse),
                RecoveredSize: 0,
        }

        if !jr.config.EnableRecovery </span><span class="cov8" title="1">{
                result.Message = "JSON recovery disabled"
                return result
        }</span>

        <span class="cov8" title="1">if jr.verboseMode </span><span class="cov8" title="1">{
                fmt.Printf("  🔧 Attempting JSON recovery for %s error (size: %d bytes)\n",
                        result.ErrorType, result.OriginalSize)
        }</span>

        // Try different recovery strategies based on error type
        <span class="cov8" title="1">switch result.ErrorType </span>{
        case "truncation":<span class="cov8" title="1">
                return jr.recoverTruncatedJSON(rawResponse, result)</span>
        case "malformed":<span class="cov8" title="1">
                return jr.recoverMalformedJSON(rawResponse, result)</span>
        case "incomplete_array":<span class="cov0" title="0">
                return jr.recoverIncompleteArray(rawResponse, result)</span>
        default:<span class="cov8" title="1">
                return jr.attemptGenericRecovery(rawResponse, result)</span>
        }
}

// categorizeError determines the type of JSON parsing error
func (jr *JSONRecoverer) categorizeError(err error) string <span class="cov8" title="1">{
        errMsg := strings.ToLower(err.Error())

        if strings.Contains(errMsg, "unexpected end of json input") ||
                strings.Contains(errMsg, "unexpected end of input") </span><span class="cov8" title="1">{
                return "truncation"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "invalid character") ||
                strings.Contains(errMsg, "looking for beginning of object") </span><span class="cov8" title="1">{
                return "malformed"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "cannot unmarshal") </span><span class="cov8" title="1">{
                return "type_mismatch"
        }</span>

        <span class="cov8" title="1">return "unknown"</span>
}

// recoverTruncatedJSON handles truncated JSON responses
func (jr *JSONRecoverer) recoverTruncatedJSON(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov8" title="1">{
        if jr.verboseMode </span><span class="cov8" title="1">{
                fmt.Printf("    🔍 Analyzing truncated JSON response\n")
        }</span>

        // Strategy 1: Try to recover from partial array
        <span class="cov8" title="1">if recovered := jr.tryRecoverPartialArray(response); recovered != nil </span><span class="cov8" title="1">{
                result.IsRecovered = true
                result.Tasks = recovered
                result.RecoveredSize = len(response)
                result.Message = fmt.Sprintf("Recovered %d tasks from truncated array", len(recovered))

                if jr.verboseMode </span><span class="cov8" title="1">{
                        fmt.Printf("    ✅ Recovered %d tasks from partial array\n", len(recovered))
                }</span>
                <span class="cov8" title="1">return result</span>
        }

        // Strategy 2: Try to find complete JSON objects within the response
        <span class="cov8" title="1">if recovered := jr.extractCompleteObjects(response); len(recovered) &gt; 0 </span><span class="cov0" title="0">{
                result.IsRecovered = true
                result.Tasks = recovered
                result.RecoveredSize = len(response)
                result.Message = fmt.Sprintf("Extracted %d complete objects", len(recovered))

                if jr.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    ✅ Extracted %d complete JSON objects\n", len(recovered))
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        <span class="cov8" title="1">result.Message = "No recoverable content found in truncated response"
        return result</span>
}

// recoverMalformedJSON handles malformed JSON responses
func (jr *JSONRecoverer) recoverMalformedJSON(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov8" title="1">{
        if jr.verboseMode </span><span class="cov8" title="1">{
                fmt.Printf("    🔍 Attempting to fix malformed JSON\n")
        }</span>

        // Try to clean up common malformation issues
        <span class="cov8" title="1">cleaned := jr.cleanMalformedJSON(response)

        var tasks []TaskRequest
        if err := json.Unmarshal([]byte(cleaned), &amp;tasks); err == nil </span><span class="cov8" title="1">{
                result.IsRecovered = true
                result.Tasks = tasks
                result.RecoveredSize = len(cleaned)
                result.Message = fmt.Sprintf("Fixed malformed JSON, recovered %d tasks", len(tasks))

                if jr.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    ✅ Fixed malformed JSON, recovered %d tasks\n", len(tasks))
                }</span>
                <span class="cov8" title="1">return result</span>
        }

        // If cleaning didn't work, try extracting objects
        <span class="cov8" title="1">if recovered := jr.extractCompleteObjects(response); len(recovered) &gt; 0 </span><span class="cov8" title="1">{
                result.IsRecovered = true
                result.Tasks = recovered
                result.RecoveredSize = len(response)
                result.Message = fmt.Sprintf("Extracted %d objects from malformed JSON", len(recovered))
                return result
        }</span>

        <span class="cov0" title="0">result.Message = "Could not repair malformed JSON"
        return result</span>
}

// recoverIncompleteArray handles incomplete array structures
func (jr *JSONRecoverer) recoverIncompleteArray(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov0" title="0">{
        if jr.verboseMode </span><span class="cov0" title="0">{
                fmt.Printf("    🔍 Attempting to complete incomplete array\n")
        }</span>

        // Try to add missing closing bracket and parse
        <span class="cov0" title="0">if recovered := jr.tryRecoverPartialArray(response); recovered != nil </span><span class="cov0" title="0">{
                result.IsRecovered = true
                result.Tasks = recovered
                result.RecoveredSize = len(response)
                result.Message = fmt.Sprintf("Completed incomplete array, recovered %d tasks", len(recovered))

                if jr.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    ✅ Completed array structure, recovered %d tasks\n", len(recovered))
                }</span>
                <span class="cov0" title="0">return result</span>
        }

        <span class="cov0" title="0">result.Message = "Could not complete incomplete array structure"
        return result</span>
}

// attemptGenericRecovery tries generic recovery strategies
func (jr *JSONRecoverer) attemptGenericRecovery(response string, result *JSONRecoveryResult) *JSONRecoveryResult <span class="cov8" title="1">{
        if jr.verboseMode </span><span class="cov0" title="0">{
                fmt.Printf("    🔍 Attempting generic JSON recovery\n")
        }</span>

        // Try all recovery strategies
        <span class="cov8" title="1">strategies := []func(string) []TaskRequest{
                jr.tryRecoverPartialArray,
                jr.extractCompleteObjects,
        }

        for i, strategy := range strategies </span><span class="cov8" title="1">{
                if recovered := strategy(response); len(recovered) &gt; 0 </span><span class="cov0" title="0">{
                        result.IsRecovered = true
                        result.Tasks = recovered
                        result.RecoveredSize = len(response)
                        result.Message = fmt.Sprintf("Generic recovery strategy %d succeeded, recovered %d tasks", i+1, len(recovered))

                        if jr.verboseMode </span><span class="cov0" title="0">{
                                fmt.Printf("    ✅ Generic strategy %d recovered %d tasks\n", i+1, len(recovered))
                        }</span>
                        <span class="cov0" title="0">return result</span>
                }
        }

        <span class="cov8" title="1">result.Message = "All recovery strategies failed"
        return result</span>
}

// tryRecoverPartialArray attempts to recover from a partial JSON array
func (jr *JSONRecoverer) tryRecoverPartialArray(response string) []TaskRequest <span class="cov8" title="1">{
        // Find the start of the JSON array
        arrayStart := strings.Index(response, "[")
        if arrayStart == -1 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Look for the last complete object before truncation
        <span class="cov8" title="1">arrayContent := response[arrayStart+1:]

        // Try to find complete JSON objects within the array
        objects := jr.findCompleteJSONObjects(arrayContent)
        if len(objects) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Reconstruct array with complete objects
        <span class="cov8" title="1">reconstructed := "[" + strings.Join(objects, ",") + "]"

        var tasks []TaskRequest
        if err := json.Unmarshal([]byte(reconstructed), &amp;tasks); err == nil </span><span class="cov8" title="1">{
                return tasks
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// extractCompleteObjects finds and extracts complete JSON objects from response
func (jr *JSONRecoverer) extractCompleteObjects(response string) []TaskRequest <span class="cov8" title="1">{
        objects := jr.findCompleteJSONObjects(response)
        if len(objects) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var allTasks []TaskRequest
        for _, objStr := range objects </span><span class="cov8" title="1">{
                var task TaskRequest
                if err := json.Unmarshal([]byte(objStr), &amp;task); err == nil </span><span class="cov8" title="1">{
                        // Validate that this looks like a valid task
                        if jr.isValidTaskRequest(task) </span><span class="cov8" title="1">{
                                allTasks = append(allTasks, task)
                        }</span>
                }
        }

        <span class="cov8" title="1">return allTasks</span>
}

// findCompleteJSONObjects locates complete JSON objects in a string
func (jr *JSONRecoverer) findCompleteJSONObjects(text string) []string <span class="cov8" title="1">{
        var objects []string
        braceCount := 0
        start := -1
        inString := false
        escaped := false

        for i, char := range text </span><span class="cov8" title="1">{
                if escaped </span><span class="cov8" title="1">{
                        escaped = false
                        continue</span>
                }

                <span class="cov8" title="1">if char == '\\' </span><span class="cov8" title="1">{
                        escaped = true
                        continue</span>
                }

                <span class="cov8" title="1">if char == '"' </span><span class="cov8" title="1">{
                        inString = !inString
                        continue</span>
                }

                <span class="cov8" title="1">if inString </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">switch char </span>{
                case '{':<span class="cov8" title="1">
                        if braceCount == 0 </span><span class="cov8" title="1">{
                                start = i
                        }</span>
                        <span class="cov8" title="1">braceCount++</span>
                case '}':<span class="cov8" title="1">
                        braceCount--
                        if braceCount == 0 &amp;&amp; start != -1 </span><span class="cov8" title="1">{
                                // Found complete object
                                objStr := text[start : i+1]
                                objects = append(objects, objStr)
                                start = -1
                        }</span>
                }
        }

        <span class="cov8" title="1">return objects</span>
}

// cleanMalformedJSON attempts to fix common JSON malformation issues
func (jr *JSONRecoverer) cleanMalformedJSON(response string) string <span class="cov8" title="1">{
        // Remove common prefixes/suffixes that aren't JSON
        cleaned := strings.TrimSpace(response)

        // Remove markdown code block markers
        cleaned = regexp.MustCompile("```(?:json)?\n?").ReplaceAllString(cleaned, "")
        cleaned = regexp.MustCompile("\n?```").ReplaceAllString(cleaned, "")

        // Fix common trailing comma issues
        cleaned = regexp.MustCompile(`,\s*]`).ReplaceAllString(cleaned, "]")
        cleaned = regexp.MustCompile(`,\s*}`).ReplaceAllString(cleaned, "}")

        // Fix missing quotes around field names
        cleaned = regexp.MustCompile(`(\w+):`).ReplaceAllString(cleaned, `"$1":`)

        return strings.TrimSpace(cleaned)
}</span>

// isValidTaskRequest validates that a task request has required fields
func (jr *JSONRecoverer) isValidTaskRequest(task TaskRequest) bool <span class="cov8" title="1">{
        return task.Description != "" &amp;&amp;
                task.OriginText != "" &amp;&amp;
                task.Priority != "" &amp;&amp;
                task.SourceCommentID != 0
}</span>

// LogRecoveryAttempt logs the recovery attempt if configured
func (jr *JSONRecoverer) LogRecoveryAttempt(result *JSONRecoveryResult) <span class="cov0" title="0">{
        if !jr.config.LogTruncatedResponses </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if jr.verboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  📊 JSON Recovery Summary:\n")
                fmt.Printf("    - Error Type: %s\n", result.ErrorType)
                fmt.Printf("    - Recovery Success: %v\n", result.IsRecovered)
                fmt.Printf("    - Tasks Recovered: %d\n", len(result.Tasks))
                fmt.Printf("    - Original Size: %d bytes\n", result.OriginalSize)
                fmt.Printf("    - Message: %s\n", result.Message)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package ai

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "strings"
        "sync"
)

// MockClaudeClient implements ClaudeClient for testing
type MockClaudeClient struct {
        // Responses maps input patterns to responses
        Responses map[string]string
        // Error to return if set
        Error error
        // CallCount tracks number of calls
        CallCount int
        // LastInput tracks the last input received
        LastInput string
        // mu protects concurrent access to CallCount and LastInput
        mu sync.Mutex
}

// NewMockClaudeClient creates a new mock Claude client
func NewMockClaudeClient() *MockClaudeClient <span class="cov8" title="1">{
        return &amp;MockClaudeClient{
                Responses: make(map[string]string),
        }
}</span>

// Execute returns a mocked response
func (m *MockClaudeClient) Execute(ctx context.Context, input string, outputFormat string) (string, error) <span class="cov8" title="1">{
        // Protect concurrent access
        m.mu.Lock()
        m.CallCount++
        m.LastInput = input
        m.mu.Unlock()

        if m.Error != nil </span><span class="cov8" title="1">{
                return "", m.Error
        }</span>

        // Extract comment ID, file, and line from the prompt
        <span class="cov8" title="1">var commentID int64
        var reviewID int64
        var file string
        var lineNum int
        lines := strings.Split(input, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(line, "- Comment ID: ") </span><span class="cov8" title="1">{
                        _, _ = fmt.Sscanf(line, "- Comment ID: %d", &amp;commentID)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(line, "- Review ID: ") </span><span class="cov8" title="1">{
                        _, _ = fmt.Sscanf(line, "- Review ID: %d", &amp;reviewID)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(line, "- File: ") </span><span class="cov8" title="1">{
                        parts := strings.Split(line, ":")
                        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                file = strings.TrimPrefix(parts[0], "- File: ")
                                _, _ = fmt.Sscanf(parts[1], "%d", &amp;lineNum)
                        }</span>
                }
        }

        // Look for a matching response pattern
        <span class="cov8" title="1">for pattern, response := range m.Responses </span><span class="cov8" title="1">{
                if strings.Contains(input, pattern) </span><span class="cov8" title="1">{
                        // Replace dynamic values in response
                        if commentID &gt; 0 </span><span class="cov8" title="1">{
                                response = strings.ReplaceAll(response, `"source_comment_id": 0`, fmt.Sprintf(`"source_comment_id": %d`, commentID))
                        }</span>
                        <span class="cov8" title="1">if reviewID &gt; 0 </span><span class="cov8" title="1">{
                                response = strings.ReplaceAll(response, `"source_review_id": 0`, fmt.Sprintf(`"source_review_id": %d`, reviewID))
                        }</span>
                        <span class="cov8" title="1">if file != "" </span><span class="cov8" title="1">{
                                response = strings.ReplaceAll(response, `"file": ""`, fmt.Sprintf(`"file": "%s"`, file))
                        }</span>
                        <span class="cov8" title="1">if lineNum &gt; 0 </span><span class="cov0" title="0">{
                                response = strings.ReplaceAll(response, `"line": 0`, fmt.Sprintf(`"line": %d`, lineNum))
                        }</span>

                        // Wrap response in Claude CLI format
                        <span class="cov8" title="1">if outputFormat == "json" </span><span class="cov8" title="1">{
                                wrapped := map[string]interface{}{
                                        "type":     "text",
                                        "subtype":  "assistant_response",
                                        "is_error": false,
                                        "result":   response,
                                }
                                data, _ := json.Marshal(wrapped)
                                return string(data), nil
                        }</span>
                        <span class="cov0" title="0">return response, nil</span>
                }
        }

        // Default response based on input content
        <span class="cov8" title="1">var task TaskRequest
        if strings.Contains(input, "nit:") || strings.Contains(input, "minor:") </span><span class="cov8" title="1">{
                // Generate a task with low priority
                task = TaskRequest{
                        Description:     "Fix minor issue",
                        OriginText:      extractCommentText(input),
                        Priority:        "low",
                        SourceReviewID:  reviewID,
                        SourceCommentID: commentID,
                        File:            file,
                        Line:            lineNum,
                        Status:          "pending",
                        TaskIndex:       0,
                }
        }</span> else<span class="cov8" title="1"> {
                // Default task generation
                task = TaskRequest{
                        Description:     "Fix the issue mentioned in the comment",
                        OriginText:      extractCommentText(input),
                        Priority:        "medium",
                        SourceReviewID:  reviewID,
                        SourceCommentID: commentID,
                        File:            file,
                        Line:            lineNum,
                        Status:          "todo",
                        TaskIndex:       0,
                }
        }</span>

        <span class="cov8" title="1">if outputFormat == "json" </span><span class="cov8" title="1">{
                data, _ := json.Marshal([]TaskRequest{task})
                wrapped := map[string]interface{}{
                        "type":     "text",
                        "subtype":  "assistant_response",
                        "is_error": false,
                        "result":   string(data),
                }
                wrapData, _ := json.Marshal(wrapped)
                return string(wrapData), nil
        }</span>

        <span class="cov0" title="0">return "Generated 1 task", nil</span>
}

// extractCommentText extracts the comment text from the prompt
func extractCommentText(input string) string <span class="cov8" title="1">{
        lines := strings.Split(input, "\n")
        inComment := false
        var commentText []string

        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(line, "- Comment Text: ") </span><span class="cov8" title="1">{
                        text := strings.TrimPrefix(line, "- Comment Text: ")
                        return text
                }</span>
                // Handle multi-line comments
                <span class="cov8" title="1">if inComment </span><span class="cov0" title="0">{
                        if strings.HasPrefix(line, "-") || line == "" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">commentText = append(commentText, line)</span>
                }
        }

        <span class="cov8" title="1">if len(commentText) &gt; 0 </span><span class="cov0" title="0">{
                return strings.Join(commentText, "\n")
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// MockCommandExecutor implements CommandExecutor for testing
type MockCommandExecutor struct {
        // Responses maps command patterns to responses
        Responses map[string][]byte
        // Error to return if set
        Error error
        // CallCount tracks number of calls
        CallCount int
        // LastCommand tracks the last command executed
        LastCommand string
        // LastArgs tracks the last args used
        LastArgs []string
        // mu protects concurrent access to CallCount, LastCommand, and LastArgs
        mu sync.Mutex
}

// NewMockCommandExecutor creates a new mock command executor
func NewMockCommandExecutor() *MockCommandExecutor <span class="cov0" title="0">{
        return &amp;MockCommandExecutor{
                Responses: make(map[string][]byte),
        }
}</span>

// Execute returns a mocked response
func (m *MockCommandExecutor) Execute(ctx context.Context, name string, args []string, stdin io.Reader) ([]byte, error) <span class="cov0" title="0">{
        // Protect concurrent access
        m.mu.Lock()
        m.CallCount++
        m.LastCommand = name
        m.LastArgs = args
        m.mu.Unlock()

        if m.Error != nil </span><span class="cov0" title="0">{
                return nil, m.Error
        }</span>

        // Look for a matching response
        <span class="cov0" title="0">key := name + " " + strings.Join(args, " ")
        if response, ok := m.Responses[key]; ok </span><span class="cov0" title="0">{
                return response, nil
        }</span>

        // Default response
        <span class="cov0" title="0">return []byte("mock output"), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package ai

import (
        "fmt"
        "sort"
        "strings"

        "reviewtask/internal/github"
)

// PromptSizeTracker tracks the size of different prompt components
type PromptSizeTracker struct {
        SystemPrompt     int
        LanguagePrompt   int
        PriorityPrompt   int
        NitpickPrompt    int
        ReviewsData      int
        ReviewBodies     int
        ReviewComments   int
        TotalSize        int
        Limit            int
        LargestComment   CommentSize
        ReviewBreakdown  []ReviewSize
        CommentBreakdown []CommentSize
}

// ReviewSize represents size information for a single review
type ReviewSize struct {
        ReviewID     int64
        ReviewerName string
        BodySize     int
        CommentsSize int
        TotalSize    int
}

// CommentSize represents size information for a single comment
type CommentSize struct {
        CommentID int64
        Author    string
        FileInfo  string
        Size      int
}

// NewPromptSizeTracker creates a new tracker with the default limit
func NewPromptSizeTracker() *PromptSizeTracker <span class="cov8" title="1">{
        return &amp;PromptSizeTracker{
                Limit:            32 * 1024, // 32KB
                ReviewBreakdown:  make([]ReviewSize, 0),
                CommentBreakdown: make([]CommentSize, 0),
        }
}</span>

// TrackSystemPrompt tracks the system prompt component
func (t *PromptSizeTracker) TrackSystemPrompt(prompt string) <span class="cov8" title="1">{
        t.SystemPrompt = len(prompt)
        t.updateTotal()
}</span>

// TrackLanguagePrompt tracks the language instruction component
func (t *PromptSizeTracker) TrackLanguagePrompt(prompt string) <span class="cov8" title="1">{
        t.LanguagePrompt = len(prompt)
        t.updateTotal()
}</span>

// TrackPriorityPrompt tracks the priority rules component
func (t *PromptSizeTracker) TrackPriorityPrompt(prompt string) <span class="cov8" title="1">{
        t.PriorityPrompt = len(prompt)
        t.updateTotal()
}</span>

// TrackNitpickPrompt tracks the nitpick handling component
func (t *PromptSizeTracker) TrackNitpickPrompt(prompt string) <span class="cov8" title="1">{
        t.NitpickPrompt = len(prompt)
        t.updateTotal()
}</span>

// TrackReviewsData tracks the reviews data and provides breakdown
func (t *PromptSizeTracker) TrackReviewsData(data string, reviews []github.Review) <span class="cov8" title="1">{
        t.ReviewsData = len(data)
        t.analyzeReviews(reviews)
        t.updateTotal()
}</span>

// analyzeReviews provides detailed breakdown of review sizes
func (t *PromptSizeTracker) analyzeReviews(reviews []github.Review) <span class="cov8" title="1">{
        t.ReviewBreakdown = make([]ReviewSize, 0, len(reviews))
        t.CommentBreakdown = make([]CommentSize, 0)
        t.ReviewBodies = 0
        t.ReviewComments = 0

        for _, review := range reviews </span><span class="cov8" title="1">{
                reviewSize := ReviewSize{
                        ReviewID:     review.ID,
                        ReviewerName: review.Reviewer,
                }

                // Track review body size
                if review.Body != "" </span><span class="cov8" title="1">{
                        bodySize := len(review.Body)
                        reviewSize.BodySize = bodySize
                        t.ReviewBodies += bodySize
                }</span>

                // Track comments size
                <span class="cov8" title="1">for _, comment := range review.Comments </span><span class="cov8" title="1">{
                        commentSize := len(comment.Body)

                        // Add replies size
                        for _, reply := range comment.Replies </span><span class="cov8" title="1">{
                                commentSize += len(reply.Body) + len(reply.Author) + 10 // Account for formatting
                        }</span>

                        <span class="cov8" title="1">reviewSize.CommentsSize += commentSize
                        t.ReviewComments += commentSize

                        // Track individual comment
                        cs := CommentSize{
                                CommentID: comment.ID,
                                Author:    comment.Author,
                                FileInfo:  fmt.Sprintf("%s:%d", comment.File, comment.Line),
                                Size:      commentSize,
                        }
                        t.CommentBreakdown = append(t.CommentBreakdown, cs)

                        // Track largest comment
                        if cs.Size &gt; t.LargestComment.Size </span><span class="cov8" title="1">{
                                t.LargestComment = cs
                        }</span>
                }

                <span class="cov8" title="1">reviewSize.TotalSize = reviewSize.BodySize + reviewSize.CommentsSize
                t.ReviewBreakdown = append(t.ReviewBreakdown, reviewSize)</span>
        }
}

// updateTotal updates the total size
func (t *PromptSizeTracker) updateTotal() <span class="cov8" title="1">{
        t.TotalSize = t.SystemPrompt + t.LanguagePrompt + t.PriorityPrompt +
                t.NitpickPrompt + t.ReviewsData
}</span>

// IsExceeded returns true if the total size exceeds the limit
func (t *PromptSizeTracker) IsExceeded() bool <span class="cov8" title="1">{
        return t.TotalSize &gt; t.Limit
}</span>

// GetLargestComponent returns the name and size of the largest component
func (t *PromptSizeTracker) GetLargestComponent() (string, int) <span class="cov8" title="1">{
        components := map[string]int{
                "System prompt":     t.SystemPrompt,
                "Language settings": t.LanguagePrompt,
                "Priority rules":    t.PriorityPrompt,
                "Nitpick rules":     t.NitpickPrompt,
                "Review data":       t.ReviewsData,
        }

        var largest string = "System prompt" // Default to first component
        var largestSize int
        for name, size := range components </span><span class="cov8" title="1">{
                if size &gt; largestSize </span><span class="cov8" title="1">{
                        largest = name
                        largestSize = size
                }</span>
        }

        <span class="cov8" title="1">return largest, largestSize</span>
}

// GenerateReport generates a detailed size breakdown report
func (t *PromptSizeTracker) GenerateReport() string <span class="cov8" title="1">{
        var report strings.Builder

        report.WriteString("Prompt size breakdown:\n")

        // Component breakdown
        components := []struct {
                name string
                size int
        }{
                {"System prompt", t.SystemPrompt},
                {"Language settings", t.LanguagePrompt},
                {"Priority rules", t.PriorityPrompt},
                {"Nitpick rules", t.NitpickPrompt},
                {"Review data", t.ReviewsData},
        }

        largestComponent, _ := t.GetLargestComponent()

        for _, comp := range components </span><span class="cov8" title="1">{
                percentage := float64(comp.size) / float64(t.TotalSize) * 100
                marker := ""
                if comp.name == largestComponent </span><span class="cov8" title="1">{
                        marker = " ← LARGEST"
                }</span>
                <span class="cov8" title="1">report.WriteString(fmt.Sprintf("  %-18s %7d bytes (%4.1f%%)%s\n",
                        comp.name+":", comp.size, percentage, marker))</span>
        }

        <span class="cov8" title="1">report.WriteString("  ─────────────────────────────────────────\n")
        report.WriteString(fmt.Sprintf("  Total:             %7d bytes (limit: %d bytes)\n",
                t.TotalSize, t.Limit))

        // Review data breakdown if it's the largest
        if largestComponent == "Review data" &amp;&amp; len(t.ReviewBreakdown) &gt; 0 </span><span class="cov8" title="1">{
                report.WriteString("\n📊 Review data breakdown:\n")
                report.WriteString(fmt.Sprintf("  - Review bodies: %d reviews, %d bytes\n",
                        len(t.ReviewBreakdown), t.ReviewBodies))
                report.WriteString(fmt.Sprintf("  - Comments: %d comments, %d bytes\n",
                        len(t.CommentBreakdown), t.ReviewComments))

                if t.LargestComment.Size &gt; 0 </span><span class="cov8" title="1">{
                        report.WriteString(fmt.Sprintf("  - Largest comment: ID %d (%d bytes)\n",
                                t.LargestComment.CommentID, t.LargestComment.Size))
                }</span>
        }

        <span class="cov8" title="1">return report.String()</span>
}

// GenerateSuggestions generates optimization suggestions based on the size analysis
func (t *PromptSizeTracker) GenerateSuggestions() string <span class="cov8" title="1">{
        if !t.IsExceeded() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">var suggestions strings.Builder
        suggestions.WriteString("\n💡 Suggestions:\n")

        largestComponent, _ := t.GetLargestComponent()
        excessSize := t.TotalSize - t.Limit

        switch largestComponent </span>{
        case "Review data":<span class="cov8" title="1">
                suggestions.WriteString("  1. The review data is too large. Consider:\n")
                suggestions.WriteString("     - Processing reviews in smaller batches\n")
                suggestions.WriteString("     - Using incremental processing (already enabled)\n")

                if t.LargestComment.Size &gt; 5000 </span><span class="cov8" title="1">{
                        suggestions.WriteString("     - Truncating very long comments\n")
                }</span>

                <span class="cov8" title="1">suggestions.WriteString(fmt.Sprintf("\n  2. This PR has %d comments. The system will automatically:\n",
                        len(t.CommentBreakdown)))
                suggestions.WriteString("     - Use parallel processing for individual comments\n")
                suggestions.WriteString("     - Process in batches to avoid size limits\n")</span>

        case "System prompt":<span class="cov8" title="1">
                suggestions.WriteString("  1. The system prompt is unusually large.\n")
                suggestions.WriteString("     - Review the task generation instructions\n")
                suggestions.WriteString("     - Consider simplifying the prompt template\n")</span>

        default:<span class="cov0" title="0">
                suggestions.WriteString(fmt.Sprintf("  1. The %s component is too large.\n", largestComponent))
                suggestions.WriteString(fmt.Sprintf("     - Need to reduce by at least %d bytes\n", excessSize))</span>
        }

        // Show top 3 largest reviews if relevant
        <span class="cov8" title="1">if largestComponent == "Review data" &amp;&amp; len(t.ReviewBreakdown) &gt; 3 </span><span class="cov0" title="0">{
                sort.Slice(t.ReviewBreakdown, func(i, j int) bool </span><span class="cov0" title="0">{
                        return t.ReviewBreakdown[i].TotalSize &gt; t.ReviewBreakdown[j].TotalSize
                }</span>)

                <span class="cov0" title="0">suggestions.WriteString("\n  3. Largest reviews:\n")
                for i := 0; i &lt; 3 &amp;&amp; i &lt; len(t.ReviewBreakdown); i++ </span><span class="cov0" title="0">{
                        r := t.ReviewBreakdown[i]
                        suggestions.WriteString(fmt.Sprintf("     - Review %d by %s: %d bytes\n",
                                r.ReviewID, r.ReviewerName, r.TotalSize))
                }</span>
        }

        <span class="cov8" title="1">return suggestions.String()</span>
}

// GenerateErrorMessage creates a detailed error message for prompt size exceeded
func (t *PromptSizeTracker) GenerateErrorMessage() string <span class="cov8" title="1">{
        var msg strings.Builder

        msg.WriteString("❌ Prompt size limit exceeded!\n\n")
        msg.WriteString(t.GenerateReport())
        msg.WriteString(t.GenerateSuggestions())

        return msg.String()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package ai

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"
)

// ResponseMonitor tracks and analyzes Claude API response patterns for optimization
type ResponseMonitor struct {
        config      *ResponseMonitorConfig
        verboseMode bool
        dataFile    string
}

// ResponseMonitorConfig contains configuration for response monitoring
type ResponseMonitorConfig struct {
        EnableMonitoring      bool          `json:"enable_monitoring"`
        CollectionEnabled     bool          `json:"collection_enabled"`
        AnalysisEnabled       bool          `json:"analysis_enabled"`
        DataRetentionDays     int           `json:"data_retention_days"`
        MaxEventsPerSession   int           `json:"max_events_per_session"`
        AutoOptimizeThreshold float64       `json:"auto_optimize_threshold"`
        ReportingInterval     time.Duration `json:"reporting_interval"`
}

// ResponseEvent records a single API response event
type ResponseEvent struct {
        Timestamp       time.Time `json:"timestamp"`
        SessionID       string    `json:"session_id"`
        PromptSize      int       `json:"prompt_size"`
        ResponseSize    int       `json:"response_size"`
        ProcessingTime  int64     `json:"processing_time_ms"`
        Success         bool      `json:"success"`
        ErrorType       string    `json:"error_type,omitempty"`
        RecoveryUsed    bool      `json:"recovery_used"`
        RetryCount      int       `json:"retry_count"`
        TruncationScore float64   `json:"truncation_score"`
        TasksExtracted  int       `json:"tasks_extracted"`
        PromptOptimized bool      `json:"prompt_optimized"`
}

// ResponseAnalytics contains aggregated response analytics
type ResponseAnalytics struct {
        TotalRequests         int                 `json:"total_requests"`
        SuccessRate           float64             `json:"success_rate"`
        AveragePromptSize     float64             `json:"average_prompt_size"`
        AverageResponseSize   float64             `json:"average_response_size"`
        AverageProcessingTime float64             `json:"average_processing_time_ms"`
        RecoveryRate          float64             `json:"recovery_rate"`
        ErrorDistribution     map[string]int      `json:"error_distribution"`
        TruncationPatterns    TruncationAnalytics `json:"truncation_patterns"`
        OptimizationImpact    OptimizationMetrics `json:"optimization_impact"`
        Recommendations       []OptimizationTip   `json:"recommendations"`
}

// TruncationAnalytics provides insights into truncation patterns
type TruncationAnalytics struct {
        TruncationRate         float64 `json:"truncation_rate"`
        AverageTruncationScore float64 `json:"average_truncation_score"`
        OptimalPromptSize      int     `json:"optimal_prompt_size"`
        HighRiskSizeThreshold  int     `json:"high_risk_size_threshold"`
}

// OptimizationMetrics tracks the impact of prompt optimizations
type OptimizationMetrics struct {
        OptimizationUsageRate   float64 `json:"optimization_usage_rate"`
        SuccessRateImprovement  float64 `json:"success_rate_improvement"`
        SizeReductionAverage    float64 `json:"size_reduction_average"`
        ResponseTimeImprovement float64 `json:"response_time_improvement"`
}

// OptimizationTip provides actionable optimization recommendations
type OptimizationTip struct {
        Type        string  `json:"type"`
        Priority    string  `json:"priority"`
        Description string  `json:"description"`
        Impact      string  `json:"impact"`
        Confidence  float64 `json:"confidence"`
}

// ResponseSession tracks events within a single session
type ResponseSession struct {
        // Reserved for future use; keep exported type minimal to avoid unused warnings
}

// NewResponseMonitor creates a new response monitoring system
func NewResponseMonitor(verboseMode bool) *ResponseMonitor <span class="cov8" title="1">{
        dataDir := ".pr-review/analytics"
        return &amp;ResponseMonitor{
                config: &amp;ResponseMonitorConfig{
                        EnableMonitoring:      true,
                        CollectionEnabled:     true,
                        AnalysisEnabled:       true,
                        DataRetentionDays:     30,
                        MaxEventsPerSession:   100,
                        AutoOptimizeThreshold: 0.6, // Trigger optimization if success rate &lt; 60%
                        ReportingInterval:     time.Hour * 24,
                },
                verboseMode: verboseMode,
                dataFile:    filepath.Join(dataDir, "response_events.json"),
        }
}</span>

// RecordEvent records a response event for analysis
func (rm *ResponseMonitor) RecordEvent(event ResponseEvent) error <span class="cov8" title="1">{
        if !rm.config.EnableMonitoring || !rm.config.CollectionEnabled </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Ensure data directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(rm.dataFile), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create analytics directory: %w", err)
        }</span>

        // Load existing events
        <span class="cov8" title="1">events, err := rm.loadEvents()
        if err != nil </span><span class="cov0" title="0">{
                if rm.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("    ⚠️  Warning: Could not load existing events: %v\n", err)
                }</span>
                <span class="cov0" title="0">events = []ResponseEvent{}</span>
        }

        // Add new event
        <span class="cov8" title="1">events = append(events, event)

        // Apply retention policy
        events = rm.applyRetentionPolicy(events)

        // Save updated events
        if err := rm.saveEvents(events); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save response event: %w", err)
        }</span>

        <span class="cov8" title="1">if rm.verboseMode </span><span class="cov8" title="1">{
                fmt.Printf("    📊 Response event recorded: prompt=%d, response=%d, success=%v\n",
                        event.PromptSize, event.ResponseSize, event.Success)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AnalyzePerformance generates comprehensive performance analytics
func (rm *ResponseMonitor) AnalyzePerformance() (*ResponseAnalytics, error) <span class="cov8" title="1">{
        if !rm.config.EnableMonitoring || !rm.config.AnalysisEnabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("response analysis is disabled")
        }</span>

        <span class="cov8" title="1">events, err := rm.loadEvents()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load events for analysis: %w", err)
        }</span>

        <span class="cov8" title="1">if len(events) == 0 </span><span class="cov8" title="1">{
                return &amp;ResponseAnalytics{
                        TotalRequests: 0,
                        SuccessRate:   0,
                        TruncationPatterns: TruncationAnalytics{
                                OptimalPromptSize:     20000,
                                HighRiskSizeThreshold: 30000,
                        },
                        Recommendations: []OptimizationTip{},
                }, nil
        }</span>

        <span class="cov8" title="1">analytics := rm.calculateAnalytics(events)
        analytics.Recommendations = rm.generateRecommendations(analytics, events)

        return analytics, nil</span>
}

// GetOptimalPromptSize suggests optimal prompt size based on historical data
func (rm *ResponseMonitor) GetOptimalPromptSize() (int, error) <span class="cov8" title="1">{
        analytics, err := rm.AnalyzePerformance()
        if err != nil </span><span class="cov0" title="0">{
                return 20000, err // Default fallback
        }</span>

        <span class="cov8" title="1">return analytics.TruncationPatterns.OptimalPromptSize, nil</span>
}

// ShouldOptimizePrompt determines if prompt optimization is recommended
func (rm *ResponseMonitor) ShouldOptimizePrompt(promptSize int) bool <span class="cov8" title="1">{
        if !rm.config.EnableMonitoring </span><span class="cov8" title="1">{
                return false
        }</span>

        // Load recent analytics
        <span class="cov8" title="1">analytics, err := rm.AnalyzePerformance()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if success rate is below threshold
        <span class="cov8" title="1">if analytics.SuccessRate &lt; rm.config.AutoOptimizeThreshold </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check if prompt size exceeds high-risk threshold
        <span class="cov0" title="0">if promptSize &gt; analytics.TruncationPatterns.HighRiskSizeThreshold </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// GenerateReport creates a comprehensive performance report
func (rm *ResponseMonitor) GenerateReport() (string, error) <span class="cov8" title="1">{
        analytics, err := rm.AnalyzePerformance()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">report := fmt.Sprintf(`# Claude API Response Performance Report

## Summary Statistics
- Total Requests: %d
- Success Rate: %.1f%%
- Average Prompt Size: %.0f bytes
- Average Response Size: %.0f bytes
- Average Processing Time: %.1f ms
- Recovery Usage Rate: %.1f%%

## Truncation Analysis
- Truncation Rate: %.1f%%
- Average Truncation Score: %.2f
- Optimal Prompt Size: %d bytes
- High Risk Threshold: %d bytes

## Optimization Impact
- Optimization Usage: %.1f%%
- Success Rate Improvement: %.1f%%
- Size Reduction Average: %.1f%%
- Response Time Improvement: %.1f%%

## Error Distribution
`,
                analytics.TotalRequests,
                analytics.SuccessRate*100,
                analytics.AveragePromptSize,
                analytics.AverageResponseSize,
                analytics.AverageProcessingTime,
                analytics.RecoveryRate*100,
                analytics.TruncationPatterns.TruncationRate*100,
                analytics.TruncationPatterns.AverageTruncationScore,
                analytics.TruncationPatterns.OptimalPromptSize,
                analytics.TruncationPatterns.HighRiskSizeThreshold,
                analytics.OptimizationImpact.OptimizationUsageRate*100,
                analytics.OptimizationImpact.SuccessRateImprovement*100,
                analytics.OptimizationImpact.SizeReductionAverage*100,
                analytics.OptimizationImpact.ResponseTimeImprovement*100,
        )

        for errorType, count := range analytics.ErrorDistribution </span><span class="cov8" title="1">{
                percentage := float64(count) / float64(analytics.TotalRequests) * 100
                report += fmt.Sprintf("- %s: %d (%.1f%%)\n", errorType, count, percentage)
        }</span>

        <span class="cov8" title="1">report += "\n## Optimization Recommendations\n"
        for i, tip := range analytics.Recommendations </span><span class="cov8" title="1">{
                report += fmt.Sprintf("%d. **%s** (%s priority, %.0f%% confidence)\n   %s\n   Impact: %s\n\n",
                        i+1, tip.Description, tip.Priority, tip.Confidence*100, tip.Type, tip.Impact)
        }</span>

        <span class="cov8" title="1">return report, nil</span>
}

// loadEvents loads stored response events from disk
func (rm *ResponseMonitor) loadEvents() ([]ResponseEvent, error) <span class="cov8" title="1">{
        if _, err := os.Stat(rm.dataFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []ResponseEvent{}, nil
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(rm.dataFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var events []ResponseEvent
        if err := json.Unmarshal(data, &amp;events); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return events, nil</span>
}

// saveEvents saves response events to disk
func (rm *ResponseMonitor) saveEvents(events []ResponseEvent) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(events, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(rm.dataFile, data, 0644)</span>
}

// applyRetentionPolicy removes old events based on retention settings
func (rm *ResponseMonitor) applyRetentionPolicy(events []ResponseEvent) []ResponseEvent <span class="cov8" title="1">{
        if rm.config.DataRetentionDays &lt;= 0 </span><span class="cov8" title="1">{
                return events
        }</span>

        <span class="cov8" title="1">cutoff := time.Now().AddDate(0, 0, -rm.config.DataRetentionDays)
        var filtered []ResponseEvent

        for _, event := range events </span><span class="cov8" title="1">{
                if event.Timestamp.After(cutoff) </span><span class="cov8" title="1">{
                        filtered = append(filtered, event)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

// calculateAnalytics computes analytics from event data
func (rm *ResponseMonitor) calculateAnalytics(events []ResponseEvent) *ResponseAnalytics <span class="cov8" title="1">{
        if len(events) == 0 </span><span class="cov8" title="1">{
                return &amp;ResponseAnalytics{}
        }</span>

        <span class="cov8" title="1">totalRequests := len(events)
        successCount := 0
        recoveryCount := 0
        optimizationCount := 0
        totalPromptSize := 0
        totalResponseSize := 0
        totalProcessingTime := int64(0)
        truncationEvents := 0
        totalTruncationScore := 0.0
        errorCounts := make(map[string]int)

        // Separate analysis for optimized vs non-optimized requests
        optimizedEvents := []ResponseEvent{}
        nonOptimizedEvents := []ResponseEvent{}

        for _, event := range events </span><span class="cov8" title="1">{
                totalPromptSize += event.PromptSize
                totalResponseSize += event.ResponseSize
                totalProcessingTime += event.ProcessingTime

                if event.Success </span><span class="cov8" title="1">{
                        successCount++
                }</span>

                <span class="cov8" title="1">if event.RecoveryUsed </span><span class="cov8" title="1">{
                        recoveryCount++
                }</span>

                <span class="cov8" title="1">if event.PromptOptimized </span><span class="cov8" title="1">{
                        optimizationCount++
                        optimizedEvents = append(optimizedEvents, event)
                }</span> else<span class="cov8" title="1"> {
                        nonOptimizedEvents = append(nonOptimizedEvents, event)
                }</span>

                <span class="cov8" title="1">if event.TruncationScore &gt; 0 </span><span class="cov8" title="1">{
                        truncationEvents++
                        totalTruncationScore += event.TruncationScore
                }</span>

                <span class="cov8" title="1">if event.ErrorType != "" </span><span class="cov8" title="1">{
                        errorCounts[event.ErrorType]++
                }</span>
        }

        <span class="cov8" title="1">analytics := &amp;ResponseAnalytics{
                TotalRequests:         totalRequests,
                SuccessRate:           float64(successCount) / float64(totalRequests),
                AveragePromptSize:     float64(totalPromptSize) / float64(totalRequests),
                AverageResponseSize:   float64(totalResponseSize) / float64(totalRequests),
                AverageProcessingTime: float64(totalProcessingTime) / float64(totalRequests),
                RecoveryRate:          float64(recoveryCount) / float64(totalRequests),
                ErrorDistribution:     errorCounts,
                TruncationPatterns:    rm.analyzeTruncationPatterns(events, truncationEvents, totalTruncationScore),
                OptimizationImpact:    rm.analyzeOptimizationImpact(optimizedEvents, nonOptimizedEvents),
        }

        return analytics</span>
}

// analyzeTruncationPatterns analyzes truncation patterns in the data
func (rm *ResponseMonitor) analyzeTruncationPatterns(events []ResponseEvent, truncationEvents int, totalTruncationScore float64) TruncationAnalytics <span class="cov8" title="1">{
        if len(events) == 0 </span><span class="cov8" title="1">{
                return TruncationAnalytics{
                        OptimalPromptSize:     20000,
                        HighRiskSizeThreshold: 30000,
                }
        }</span>

        <span class="cov8" title="1">truncationRate := float64(truncationEvents) / float64(len(events))
        avgTruncationScore := 0.0
        if truncationEvents &gt; 0 </span><span class="cov8" title="1">{
                avgTruncationScore = totalTruncationScore / float64(truncationEvents)
        }</span>

        // Find optimal prompt size (size with highest success rate)
        <span class="cov8" title="1">sizeBuckets := make(map[int][]bool) // size range -&gt; success results
        for _, event := range events </span><span class="cov8" title="1">{
                bucket := (event.PromptSize / 5000) * 5000 // 5KB buckets
                sizeBuckets[bucket] = append(sizeBuckets[bucket], event.Success)
        }</span>

        <span class="cov8" title="1">optimalSize := 20000 // Default
        bestSuccessRate := 0.0
        highRiskThreshold := 30000

        for size, results := range sizeBuckets </span><span class="cov8" title="1">{
                if len(results) &lt; 3 </span><span class="cov8" title="1">{
                        continue</span> // Need at least 3 samples
                }

                <span class="cov8" title="1">successCount := 0
                for _, success := range results </span><span class="cov8" title="1">{
                        if success </span><span class="cov8" title="1">{
                                successCount++
                        }</span>
                }

                <span class="cov8" title="1">successRate := float64(successCount) / float64(len(results))
                if successRate &gt; bestSuccessRate </span><span class="cov8" title="1">{
                        bestSuccessRate = successRate
                        optimalSize = size
                }</span>

                // Determine high-risk threshold (size where success rate drops below 70%)
                <span class="cov8" title="1">if successRate &lt; 0.7 &amp;&amp; size &lt; highRiskThreshold </span><span class="cov8" title="1">{
                        highRiskThreshold = size
                }</span>
        }

        <span class="cov8" title="1">return TruncationAnalytics{
                TruncationRate:         truncationRate,
                AverageTruncationScore: avgTruncationScore,
                OptimalPromptSize:      optimalSize,
                HighRiskSizeThreshold:  highRiskThreshold,
        }</span>
}

// analyzeOptimizationImpact compares optimized vs non-optimized request performance
func (rm *ResponseMonitor) analyzeOptimizationImpact(optimized, nonOptimized []ResponseEvent) OptimizationMetrics <span class="cov8" title="1">{
        totalEvents := len(optimized) + len(nonOptimized)
        if totalEvents == 0 </span><span class="cov0" title="0">{
                return OptimizationMetrics{}
        }</span>

        <span class="cov8" title="1">optimizationUsage := float64(len(optimized)) / float64(totalEvents)

        // Calculate success rate improvement
        successRateImprovement := 0.0
        if len(optimized) &gt; 0 &amp;&amp; len(nonOptimized) &gt; 0 </span><span class="cov8" title="1">{
                optimizedSuccessRate := rm.calculateSuccessRate(optimized)
                nonOptimizedSuccessRate := rm.calculateSuccessRate(nonOptimized)
                successRateImprovement = optimizedSuccessRate - nonOptimizedSuccessRate
        }</span>

        // Calculate average size reduction (this would need to be tracked differently)
        <span class="cov8" title="1">sizeReduction := 0.3 // Placeholder - would need original vs optimized size tracking

        // Calculate response time improvement
        responseTimeImprovement := 0.0
        if len(optimized) &gt; 0 &amp;&amp; len(nonOptimized) &gt; 0 </span><span class="cov8" title="1">{
                optimizedAvgTime := rm.calculateAverageProcessingTime(optimized)
                nonOptimizedAvgTime := rm.calculateAverageProcessingTime(nonOptimized)
                if nonOptimizedAvgTime &gt; 0 </span><span class="cov8" title="1">{
                        responseTimeImprovement = (nonOptimizedAvgTime - optimizedAvgTime) / nonOptimizedAvgTime
                }</span>
        }

        <span class="cov8" title="1">return OptimizationMetrics{
                OptimizationUsageRate:   optimizationUsage,
                SuccessRateImprovement:  successRateImprovement,
                SizeReductionAverage:    sizeReduction,
                ResponseTimeImprovement: responseTimeImprovement,
        }</span>
}

// Helper functions for calculations
func (rm *ResponseMonitor) calculateSuccessRate(events []ResponseEvent) float64 <span class="cov8" title="1">{
        if len(events) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">successCount := 0
        for _, event := range events </span><span class="cov8" title="1">{
                if event.Success </span><span class="cov8" title="1">{
                        successCount++
                }</span>
        }
        <span class="cov8" title="1">return float64(successCount) / float64(len(events))</span>
}

func (rm *ResponseMonitor) calculateAverageProcessingTime(events []ResponseEvent) float64 <span class="cov8" title="1">{
        if len(events) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">total := int64(0)
        for _, event := range events </span><span class="cov8" title="1">{
                total += event.ProcessingTime
        }</span>
        <span class="cov8" title="1">return float64(total) / float64(len(events))</span>
}

// generateRecommendations creates optimization recommendations based on analytics
func (rm *ResponseMonitor) generateRecommendations(analytics *ResponseAnalytics, events []ResponseEvent) []OptimizationTip <span class="cov8" title="1">{
        var tips []OptimizationTip

        // Recommendation 1: Success rate improvement
        if analytics.SuccessRate &lt; 0.8 </span><span class="cov8" title="1">{
                priority := "high"
                if analytics.SuccessRate &lt; 0.5 </span><span class="cov8" title="1">{
                        priority = "critical"
                }</span>
                <span class="cov8" title="1">tips = append(tips, OptimizationTip{
                        Type:        "success_rate",
                        Priority:    priority,
                        Description: "Enable prompt optimization to improve success rate",
                        Impact:      fmt.Sprintf("Could improve success rate by up to %.1f%%", analytics.OptimizationImpact.SuccessRateImprovement*100),
                        Confidence:  0.85,
                })</span>
        }

        // Recommendation 2: Prompt size optimization
        <span class="cov8" title="1">if analytics.AveragePromptSize &gt; float64(analytics.TruncationPatterns.HighRiskSizeThreshold) </span><span class="cov8" title="1">{
                tips = append(tips, OptimizationTip{
                        Type:        "prompt_size",
                        Priority:    "medium",
                        Description: "Reduce average prompt size to minimize truncation risk",
                        Impact:      fmt.Sprintf("Target size: %d bytes (current avg: %.0f bytes)", analytics.TruncationPatterns.OptimalPromptSize, analytics.AveragePromptSize),
                        Confidence:  0.75,
                })
        }</span>

        // Recommendation 3: Truncation patterns
        <span class="cov8" title="1">if analytics.TruncationPatterns.TruncationRate &gt; 0.1 </span><span class="cov0" title="0">{
                tips = append(tips, OptimizationTip{
                        Type:        "truncation",
                        Priority:    "high",
                        Description: "High truncation rate detected - enable JSON recovery and retry logic",
                        Impact:      fmt.Sprintf("Could recover %.1f%% of failed requests", analytics.TruncationPatterns.TruncationRate*100),
                        Confidence:  0.9,
                })
        }</span>

        // Recommendation 4: Performance optimization
        <span class="cov8" title="1">if analytics.AverageProcessingTime &gt; 10000 </span><span class="cov0" title="0">{ // &gt; 10 seconds
                tips = append(tips, OptimizationTip{
                        Type:        "performance",
                        Priority:    "medium",
                        Description: "High processing times - consider request chunking or parallel processing",
                        Impact:      fmt.Sprintf("Could reduce processing time from %.1fs to %.1fs", analytics.AverageProcessingTime/1000, analytics.AverageProcessingTime/2000),
                        Confidence:  0.7,
                })
        }</span>

        <span class="cov8" title="1">return tips</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package ai

import (
        "fmt"
        "strings"
        "time"
)

// RetryStrategy handles intelligent retry logic for incomplete/failed API responses
type RetryStrategy struct {
        config            *RetryConfig
        verboseMode       bool
        truncationPattern *TruncationPatternDetector
}

// RetryConfig contains configuration for retry behavior
type RetryConfig struct {
        EnableSmartRetry    bool          `json:"enable_smart_retry"`
        MaxRetries          int           `json:"max_retries"`
        BaseDelay           time.Duration `json:"base_delay"`
        MaxDelay            time.Duration `json:"max_delay"`
        BackoffMultiplier   float64       `json:"backoff_multiplier"`
        TruncationThreshold int           `json:"truncation_threshold"`
        PromptSizeReduction float64       `json:"prompt_size_reduction"`
}

// RetryAttempt contains information about a retry attempt
type RetryAttempt struct {
        AttemptNumber   int           `json:"attempt_number"`
        Strategy        string        `json:"strategy"`
        PromptSize      int           `json:"prompt_size"`
        ResponseSize    int           `json:"response_size"`
        Error           string        `json:"error"`
        TruncationScore float64       `json:"truncation_score"`
        Delay           time.Duration `json:"delay"`
        AdjustedPrompt  bool          `json:"adjusted_prompt"`
}

// TruncationPatternDetector analyzes response patterns to detect truncation issues
type TruncationPatternDetector struct {
        responseSizes    []int
        truncationEvents []TruncationEvent
        verboseMode      bool
}

// TruncationEvent records a truncation occurrence
type TruncationEvent struct {
        Timestamp    time.Time `json:"timestamp"`
        PromptSize   int       `json:"prompt_size"`
        ResponseSize int       `json:"response_size"`
        ErrorType    string    `json:"error_type"`
}

// NewRetryStrategy creates a new retry strategy handler
func NewRetryStrategy(verboseMode bool) *RetryStrategy <span class="cov8" title="1">{
        return &amp;RetryStrategy{
                config: &amp;RetryConfig{
                        EnableSmartRetry:    true,
                        MaxRetries:          3,
                        BaseDelay:           time.Second * 2,
                        MaxDelay:            time.Second * 30,
                        BackoffMultiplier:   2.0,
                        TruncationThreshold: 20000, // 20KB threshold for prompt size adjustments
                        PromptSizeReduction: 0.7,   // Reduce prompt size by 30%
                },
                verboseMode:       verboseMode,
                truncationPattern: NewTruncationPatternDetector(verboseMode),
        }
}</span>

// NewTruncationPatternDetector creates a new truncation pattern detector
func NewTruncationPatternDetector(verboseMode bool) *TruncationPatternDetector <span class="cov8" title="1">{
        return &amp;TruncationPatternDetector{
                responseSizes:    make([]int, 0),
                truncationEvents: make([]TruncationEvent, 0),
                verboseMode:      verboseMode,
        }
}</span>

// ShouldRetry determines if a retry should be attempted based on error analysis
func (rs *RetryStrategy) ShouldRetry(attempt int, err error, promptSize int, responseSize int) (*RetryAttempt, bool) <span class="cov8" title="1">{
        if !rs.config.EnableSmartRetry || attempt &gt;= rs.config.MaxRetries </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        // Analyze the error to determine retry strategy
        <span class="cov8" title="1">errorType := rs.categorizeRetryError(err)
        truncationScore := rs.truncationPattern.AnalyzeResponse(promptSize, responseSize, errorType)

        retryAttempt := &amp;RetryAttempt{
                AttemptNumber:   attempt + 1,
                Strategy:        rs.determineRetryStrategy(errorType, truncationScore, promptSize),
                PromptSize:      promptSize,
                ResponseSize:    responseSize,
                Error:           err.Error(),
                TruncationScore: truncationScore,
                Delay:           rs.calculateDelay(attempt),
                AdjustedPrompt:  false,
        }

        // Record truncation event for pattern analysis
        rs.truncationPattern.RecordTruncation(promptSize, responseSize, errorType)

        if rs.verboseMode </span><span class="cov8" title="1">{
                fmt.Printf("  🔄 Retry analysis (attempt %d):\n", retryAttempt.AttemptNumber)
                fmt.Printf("    - Error type: %s\n", errorType)
                fmt.Printf("    - Truncation score: %.2f\n", truncationScore)
                fmt.Printf("    - Strategy: %s\n", retryAttempt.Strategy)
                fmt.Printf("    - Delay: %v\n", retryAttempt.Delay)
        }</span>

        <span class="cov8" title="1">return retryAttempt, true</span>
}

// categorizeRetryError categorizes errors for retry strategy selection
func (rs *RetryStrategy) categorizeRetryError(err error) string <span class="cov8" title="1">{
        errMsg := strings.ToLower(err.Error())

        if strings.Contains(errMsg, "unexpected end of json input") ||
                strings.Contains(errMsg, "unexpected end of input") </span><span class="cov8" title="1">{
                return "json_truncation"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "prompt size") &amp;&amp; strings.Contains(errMsg, "exceeds") </span><span class="cov8" title="1">{
                return "prompt_size_limit"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "rate limit") || strings.Contains(errMsg, "too many requests") </span><span class="cov8" title="1">{
                return "rate_limit"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "timeout") || strings.Contains(errMsg, "deadline exceeded") </span><span class="cov8" title="1">{
                return "timeout"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "network") || strings.Contains(errMsg, "connection") </span><span class="cov8" title="1">{
                return "network_error"
        }</span>

        <span class="cov8" title="1">if strings.Contains(errMsg, "invalid character") </span><span class="cov8" title="1">{
                return "malformed_response"
        }</span>

        <span class="cov8" title="1">return "unknown_error"</span>
}

// determineRetryStrategy selects the appropriate retry strategy
func (rs *RetryStrategy) determineRetryStrategy(errorType string, truncationScore float64, promptSize int) string <span class="cov8" title="1">{
        switch errorType </span>{
        case "json_truncation":<span class="cov8" title="1">
                if truncationScore &gt; 0.7 </span><span class="cov8" title="1">{
                        return "reduce_prompt_aggressive"
                }</span> else<span class="cov8" title="1"> if promptSize &gt; rs.config.TruncationThreshold </span><span class="cov8" title="1">{
                        return "reduce_prompt_moderate"
                }</span>
                <span class="cov8" title="1">return "simple_retry"</span>

        case "prompt_size_limit":<span class="cov8" title="1">
                return "reduce_prompt_aggressive"</span>

        case "rate_limit":<span class="cov8" title="1">
                return "exponential_backoff"</span>

        case "timeout":<span class="cov8" title="1">
                if promptSize &gt; rs.config.TruncationThreshold </span><span class="cov8" title="1">{
                        return "reduce_prompt_moderate"
                }</span>
                <span class="cov8" title="1">return "exponential_backoff"</span>

        case "network_error":<span class="cov8" title="1">
                return "exponential_backoff"</span>

        case "malformed_response":<span class="cov8" title="1">
                return "simple_retry"</span>

        default:<span class="cov8" title="1">
                return "simple_retry"</span>
        }
}

// calculateDelay calculates the retry delay using exponential backoff
func (rs *RetryStrategy) calculateDelay(attempt int) time.Duration <span class="cov8" title="1">{
        delay := rs.config.BaseDelay
        for i := 0; i &lt; attempt; i++ </span><span class="cov8" title="1">{
                delay = time.Duration(float64(delay) * rs.config.BackoffMultiplier)
        }</span>

        <span class="cov8" title="1">if delay &gt; rs.config.MaxDelay </span><span class="cov8" title="1">{
                delay = rs.config.MaxDelay
        }</span>

        <span class="cov8" title="1">return delay</span>
}

// AdjustPromptForRetry modifies the prompt based on retry strategy
func (rs *RetryStrategy) AdjustPromptForRetry(originalPrompt string, retryAttempt *RetryAttempt) string <span class="cov8" title="1">{
        switch retryAttempt.Strategy </span>{
        case "reduce_prompt_aggressive":<span class="cov8" title="1">
                return rs.reducePromptSize(originalPrompt, 0.5)</span> // 50% reduction
        case "reduce_prompt_moderate":<span class="cov8" title="1">
                return rs.reducePromptSize(originalPrompt, rs.config.PromptSizeReduction)</span>
        default:<span class="cov8" title="1">
                return originalPrompt</span>
        }
}

// reducePromptSize reduces prompt size by the specified factor
func (rs *RetryStrategy) reducePromptSize(prompt string, reductionFactor float64) string <span class="cov8" title="1">{
        if reductionFactor &gt;= 1.0 || reductionFactor &lt;= 0.0 </span><span class="cov0" title="0">{
                return prompt
        }</span>

        // Strategy: Reduce the review data section while preserving system prompts
        <span class="cov8" title="1">lines := strings.Split(prompt, "\n")

        // Find the start of review data (usually after "PR Reviews to analyze:")
        reviewStartIndex := -1
        for i, line := range lines </span><span class="cov8" title="1">{
                if strings.Contains(line, "PR Reviews to analyze:") ||
                        strings.Contains(line, "Review Context:") ||
                        strings.Contains(line, "Comment Details:") </span><span class="cov8" title="1">{
                        reviewStartIndex = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if reviewStartIndex == -1 </span><span class="cov0" title="0">{
                // If we can't find review data section, reduce overall length
                targetSize := int(float64(len(prompt)) * reductionFactor)
                if targetSize &lt; len(prompt) </span><span class="cov0" title="0">{
                        return prompt[:targetSize] + "\n\n[Content truncated for retry]"
                }</span>
                <span class="cov0" title="0">return prompt</span>
        }

        // Calculate how much review data to keep
        <span class="cov8" title="1">systemPromptSize := 0
        for i := 0; i &lt; reviewStartIndex; i++ </span><span class="cov8" title="1">{
                systemPromptSize += len(lines[i]) + 1 // +1 for newline
        }</span>

        <span class="cov8" title="1">availableSize := int(float64(len(prompt)) * reductionFactor)
        reviewDataBudget := availableSize - systemPromptSize

        if reviewDataBudget &lt;= 0 </span><span class="cov0" title="0">{
                // If system prompt is too large, return minimal version
                return strings.Join(lines[:reviewStartIndex], "\n") + "\n\n[Review data omitted for retry]"
        }</span>

        // Truncate review data to fit budget
        <span class="cov8" title="1">reviewData := strings.Join(lines[reviewStartIndex:], "\n")
        if len(reviewData) &gt; reviewDataBudget </span><span class="cov8" title="1">{
                reviewData = reviewData[:reviewDataBudget] + "\n\n[Content truncated for retry]"
        }</span>

        <span class="cov8" title="1">return strings.Join(lines[:reviewStartIndex], "\n") + "\n" + reviewData</span>
}

// ExecuteDelay waits for the calculated retry delay
func (rs *RetryStrategy) ExecuteDelay(retryAttempt *RetryAttempt) <span class="cov0" title="0">{
        if retryAttempt.Delay &gt; 0 </span><span class="cov0" title="0">{
                if rs.verboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("  ⏱️  Waiting %v before retry %d...\n", retryAttempt.Delay, retryAttempt.AttemptNumber)
                }</span>
                <span class="cov0" title="0">time.Sleep(retryAttempt.Delay)</span>
        }
}

// AnalyzeResponse analyzes response patterns for truncation detection
func (tpd *TruncationPatternDetector) AnalyzeResponse(promptSize, responseSize int, errorType string) float64 <span class="cov8" title="1">{
        tpd.responseSizes = append(tpd.responseSizes, responseSize)

        // Keep only recent response sizes (last 10)
        if len(tpd.responseSizes) &gt; 10 </span><span class="cov0" title="0">{
                tpd.responseSizes = tpd.responseSizes[len(tpd.responseSizes)-10:]
        }</span>

        // Calculate truncation likelihood score
        <span class="cov8" title="1">score := 0.0

        // Factor 1: Error type indicates truncation
        if errorType == "json_truncation" </span><span class="cov8" title="1">{
                score += 0.4
        }</span>

        // Factor 2: Prompt size vs typical limits
        <span class="cov8" title="1">if promptSize &gt; 30000 </span><span class="cov8" title="1">{ // 30KB
                score += 0.3
        }</span> else<span class="cov8" title="1"> if promptSize &gt; 20000 </span><span class="cov8" title="1">{ // 20KB
                score += 0.2
        }</span>

        // Factor 3: Response size patterns
        <span class="cov8" title="1">if len(tpd.responseSizes) &gt;= 3 </span><span class="cov8" title="1">{
                // Check if recent responses are getting smaller
                recent := tpd.responseSizes[len(tpd.responseSizes)-3:]
                if recent[2] &lt; recent[1] &amp;&amp; recent[1] &lt; recent[0] </span><span class="cov0" title="0">{
                        score += 0.2
                }</span>
        }

        // Factor 4: Absolute response size
        <span class="cov8" title="1">if responseSize &gt; 0 &amp;&amp; responseSize &lt; 1000 </span><span class="cov8" title="1">{
                score += 0.1
        }</span>

        <span class="cov8" title="1">return score</span>
}

// RecordTruncation records a truncation event for pattern analysis
func (tpd *TruncationPatternDetector) RecordTruncation(promptSize, responseSize int, errorType string) <span class="cov8" title="1">{
        event := TruncationEvent{
                Timestamp:    time.Now(),
                PromptSize:   promptSize,
                ResponseSize: responseSize,
                ErrorType:    errorType,
        }

        tpd.truncationEvents = append(tpd.truncationEvents, event)

        // Keep only recent events (last 20)
        if len(tpd.truncationEvents) &gt; 20 </span><span class="cov8" title="1">{
                tpd.truncationEvents = tpd.truncationEvents[len(tpd.truncationEvents)-20:]
        }</span>

        <span class="cov8" title="1">if tpd.verboseMode </span><span class="cov8" title="1">{
                fmt.Printf("    📊 Truncation event recorded: prompt=%d, response=%d, type=%s\n",
                        promptSize, responseSize, errorType)
        }</span>
}

// GetTruncationStats returns statistics about truncation patterns
func (tpd *TruncationPatternDetector) GetTruncationStats() map[string]interface{} <span class="cov8" title="1">{
        if len(tpd.truncationEvents) == 0 </span><span class="cov8" title="1">{
                return map[string]interface{}{
                        "total_events":          0,
                        "average_prompt_size":   0,
                        "average_response_size": 0,
                }
        }</span>

        <span class="cov8" title="1">totalPromptSize := 0
        totalResponseSize := 0
        errorTypeCounts := make(map[string]int)

        for _, event := range tpd.truncationEvents </span><span class="cov8" title="1">{
                totalPromptSize += event.PromptSize
                totalResponseSize += event.ResponseSize
                errorTypeCounts[event.ErrorType]++
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "total_events":            len(tpd.truncationEvents),
                "average_prompt_size":     totalPromptSize / len(tpd.truncationEvents),
                "average_response_size":   totalResponseSize / len(tpd.truncationEvents),
                "error_type_distribution": errorTypeCounts,
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ai

import (
        "time"

        "reviewtask/internal/storage"
)

type StatisticsManager struct {
        storageManager *storage.Manager
}

func NewStatisticsManager(storageManager *storage.Manager) *StatisticsManager <span class="cov0" title="0">{
        return &amp;StatisticsManager{
                storageManager: storageManager,
        }
}</span>

func (sm *StatisticsManager) GenerateTaskStatistics(prNumber int) (*storage.TaskStatistics, error) <span class="cov0" title="0">{
        tasks, err := sm.storageManager.GetTasksByPR(prNumber)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return sm.generateStatsFromTasks(tasks, prNumber, "")</span>
}

// GenerateCurrentBranchStatistics generates statistics for the current branch
func (sm *StatisticsManager) GenerateCurrentBranchStatistics() (*storage.TaskStatistics, error) <span class="cov0" title="0">{
        currentBranch, err := sm.storageManager.GetCurrentBranch()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return sm.GenerateBranchStatistics(currentBranch)</span>
}

// GenerateBranchStatistics generates statistics for a specific branch
func (sm *StatisticsManager) GenerateBranchStatistics(branchName string) (*storage.TaskStatistics, error) <span class="cov0" title="0">{
        prNumbers, err := sm.storageManager.GetPRsForBranch(branchName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(prNumbers) == 0 </span><span class="cov0" title="0">{
                return &amp;storage.TaskStatistics{
                        PRNumber:      -1, // Indicate this is branch stats, not single PR
                        BranchName:    branchName,
                        GeneratedAt:   time.Now().Format("2006-01-02T15:04:05Z"),
                        TotalComments: 0,
                        TotalTasks:    0,
                        CommentStats:  []storage.CommentStats{},
                        StatusSummary: storage.StatusSummary{},
                }, nil
        }</span>

        // Collect all tasks from all PRs for this branch
        <span class="cov0" title="0">var allTasks []storage.Task
        for _, prNumber := range prNumbers </span><span class="cov0" title="0">{
                tasks, err := sm.storageManager.GetTasksByPR(prNumber)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip PRs that can't be read
                }
                <span class="cov0" title="0">allTasks = append(allTasks, tasks...)</span>
        }

        <span class="cov0" title="0">return sm.generateStatsFromTasks(allTasks, -1, branchName)</span>
}

// generateStatsFromTasks is a helper function to generate statistics from a list of tasks
func (sm *StatisticsManager) generateStatsFromTasks(tasks []storage.Task, prNumber int, branchName string) (*storage.TaskStatistics, error) <span class="cov0" title="0">{
        // Group tasks by comment ID
        commentGroups := make(map[int64][]storage.Task)
        for _, task := range tasks </span><span class="cov0" title="0">{
                commentGroups[task.SourceCommentID] = append(commentGroups[task.SourceCommentID], task)
        }</span>

        <span class="cov0" title="0">var commentStats []storage.CommentStats
        statusSummary := storage.StatusSummary{}

        for commentID, commentTasks := range commentGroups </span><span class="cov0" title="0">{
                stats := storage.CommentStats{
                        CommentID:  commentID,
                        TotalTasks: len(commentTasks),
                        File:       commentTasks[0].File,
                        Line:       commentTasks[0].Line,
                        OriginText: commentTasks[0].OriginText,
                }

                // Count by status
                for _, task := range commentTasks </span><span class="cov0" title="0">{
                        switch task.Status </span>{
                        case "todo":<span class="cov0" title="0">
                                stats.PendingTasks++
                                statusSummary.Todo++</span>
                        case "doing":<span class="cov0" title="0">
                                stats.InProgressTasks++
                                statusSummary.Doing++</span>
                        case "done":<span class="cov0" title="0">
                                stats.CompletedTasks++
                                statusSummary.Done++</span>
                        case "pending":<span class="cov0" title="0">
                                stats.PendingTasks++
                                statusSummary.Pending++</span>
                        case "cancel":<span class="cov0" title="0">
                                stats.CancelledTasks++
                                statusSummary.Cancelled++</span>
                        }
                }

                <span class="cov0" title="0">commentStats = append(commentStats, stats)</span>
        }

        <span class="cov0" title="0">return &amp;storage.TaskStatistics{
                PRNumber:      prNumber,
                BranchName:    branchName,
                GeneratedAt:   time.Now().Format("2006-01-02T15:04:05Z"),
                TotalComments: len(commentGroups),
                TotalTasks:    len(tasks),
                CommentStats:  commentStats,
                StatusSummary: statusSummary,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package ai

import (
        "fmt"
        "strings"
        "sync"

        "reviewtask/internal/storage"
)

// StreamProcessor handles comment processing with streaming results
type StreamProcessor struct {
        analyzer *Analyzer
}

// NewStreamProcessor creates a new stream processor
func NewStreamProcessor(analyzer *Analyzer) *StreamProcessor <span class="cov8" title="1">{
        return &amp;StreamProcessor{
                analyzer: analyzer,
        }
}</span>

// ProcessCommentsStream processes comments with streaming results
// This allows successful tasks to be written incrementally, and failed comments to be tracked separately
func (sp *StreamProcessor) ProcessCommentsStream(comments []CommentContext, processor func(CommentContext) ([]TaskRequest, error)) ([]storage.Task, error) <span class="cov8" title="1">{
        if !sp.analyzer.config.AISettings.StreamProcessingEnabled </span><span class="cov8" title="1">{
                // Fallback to traditional parallel processing
                return sp.analyzer.processCommentsParallel(comments, processor)
        }</span>

        <span class="cov8" title="1">if sp.analyzer.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                fmt.Printf("Processing %d comments with streaming mode...\n", len(comments))
        }</span>

        <span class="cov8" title="1">type streamResult struct {
                tasks   []TaskRequest
                err     error
                index   int
                context CommentContext
                done    bool
        }

        results := make(chan streamResult, len(comments))
        var wg sync.WaitGroup

        // Process each comment in parallel (same as before)
        for i, commentCtx := range comments </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(index int, ctx CommentContext) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        tasks, err := processor(ctx)
                        results &lt;- streamResult{
                                tasks:   tasks,
                                err:     err,
                                index:   index,
                                context: ctx,
                                done:    false,
                        }
                }</span>(i, commentCtx)
        }

        // Signal completion
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                results &lt;- streamResult{done: true}
                close(results)
        }</span>()

        // Stream processing: handle results as they arrive
        <span class="cov8" title="1">var allTasks []TaskRequest
        var successfulResults []streamResult
        var failedResults []streamResult

        processed := 0
        for result := range results </span><span class="cov8" title="1">{
                if result.done </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">processed++

                if result.err != nil </span><span class="cov8" title="1">{
                        // Record failed result
                        failedResults = append(failedResults, result)

                        // Record error in error tracker
                        if sp.analyzer.errorTracker != nil </span><span class="cov8" title="1">{
                                errorType := sp.categorizeError(result.err)
                                sp.analyzer.errorTracker.RecordCommentError(result.context, errorType, result.err.Error(), 0, false, 0, 0)
                        }</span>

                        <span class="cov8" title="1">if sp.analyzer.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                                fmt.Printf("  ❌ Comment %d failed: %v\n", result.context.Comment.ID, result.err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Record successful result
                        successfulResults = append(successfulResults, result)
                        allTasks = append(allTasks, result.tasks...)

                        if sp.analyzer.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                                fmt.Printf("  ✅ Comment %d processed: %d tasks generated\n", result.context.Comment.ID, len(result.tasks))
                        }</span>
                }

                // Show progress
                <span class="cov8" title="1">if sp.analyzer.config.AISettings.VerboseMode &amp;&amp; processed%5 == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  📊 Progress: %d/%d comments processed (%d successful, %d failed)\n",
                                processed, len(comments), len(successfulResults), len(failedResults))
                }</span>
        }

        // Final progress report
        <span class="cov8" title="1">if sp.analyzer.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                fmt.Printf("  📊 Final: %d/%d comments processed (%d successful, %d failed)\n",
                        processed, len(comments), len(successfulResults), len(failedResults))
        }</span>

        // Report detailed error summary if any failures occurred
        <span class="cov8" title="1">if len(failedResults) &gt; 0 </span><span class="cov8" title="1">{
                if sp.analyzer.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                        fmt.Printf("  ⚠️  %d comment(s) failed to process:\n", len(failedResults))
                        for _, failed := range failedResults </span><span class="cov8" title="1">{
                                fmt.Printf("    • Comment %d: %v\n", failed.context.Comment.ID, failed.err)
                        }</span>
                }

                // Show error summary
                <span class="cov8" title="1">if sp.analyzer.errorTracker != nil &amp;&amp; sp.analyzer.config.AISettings.VerboseMode </span><span class="cov8" title="1">{
                        sp.analyzer.errorTracker.PrintErrorSummary()
                }</span>

                // Return error only if ALL processing failed
                <span class="cov8" title="1">if len(allTasks) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("all comment processing failed (%d errors)", len(failedResults))
                }</span>
        }

        // Convert to storage tasks
        <span class="cov8" title="1">storageTasks := sp.analyzer.convertToStorageTasks(allTasks)

        // Apply deduplication
        dedupedTasks := sp.analyzer.deduplicateTasks(storageTasks)

        if sp.analyzer.config.AISettings.DeduplicationEnabled &amp;&amp; len(dedupedTasks) &lt; len(storageTasks) &amp;&amp; sp.analyzer.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                fmt.Printf("  🔄 Deduplication: %d tasks → %d tasks (removed %d duplicates)\n",
                        len(storageTasks), len(dedupedTasks), len(storageTasks)-len(dedupedTasks))
        }</span>

        <span class="cov8" title="1">return dedupedTasks, nil</span>
}

// categorizeError categorizes errors for better tracking
func (sp *StreamProcessor) categorizeError(err error) string <span class="cov8" title="1">{
        errStr := err.Error()

        if strings.Contains(errStr, "json") || strings.Contains(errStr, "JSON") </span><span class="cov8" title="1">{
                return "json_parse"
        }</span> else<span class="cov8" title="1"> if strings.Contains(errStr, "API") || strings.Contains(errStr, "execution failed") </span><span class="cov8" title="1">{
                return "api_failure"
        }</span> else<span class="cov8" title="1"> if strings.Contains(errStr, "context") || strings.Contains(errStr, "size") || strings.Contains(errStr, "limit") </span><span class="cov8" title="1">{
                return "context_overflow"
        }</span> else<span class="cov8" title="1"> if strings.Contains(errStr, "timeout") </span><span class="cov8" title="1">{
                return "timeout"
        }</span>

        <span class="cov8" title="1">return "processing_failed"</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ai

import (
        "encoding/json"
        "fmt"
        "os/exec"
        "reviewtask/internal/config"
        "reviewtask/internal/storage"
        "strings"
)

// TaskDeduplicator handles AI-powered task deduplication
type TaskDeduplicator struct {
        config *config.Config
}

// NewTaskDeduplicator creates a new task deduplicator
func NewTaskDeduplicator(config *config.Config) *TaskDeduplicator <span class="cov8" title="1">{
        return &amp;TaskDeduplicator{
                config: config,
        }
}</span>

// DeduplicationRequest represents a request to check for duplicate tasks
type DeduplicationRequest struct {
        Tasks []TaskSummary `json:"tasks"`
}

// TaskSummary represents a simplified task for deduplication
type TaskSummary struct {
        ID          string `json:"id"`
        Description string `json:"description"`
        CommentID   int64  `json:"comment_id"`
        Priority    string `json:"priority"`
}

// DeduplicationResponse represents the AI's response about task duplicates
type DeduplicationResponse struct {
        UniqueTaskIDs   []string         `json:"unique_task_ids"`
        DuplicateGroups []DuplicateGroup `json:"duplicate_groups"`
        Reasoning       string           `json:"reasoning"`
}

// DuplicateGroup represents a group of duplicate tasks
type DuplicateGroup struct {
        PrimaryTaskID    string   `json:"primary_task_id"`
        DuplicateTaskIDs []string `json:"duplicate_task_ids"`
        Reason           string   `json:"reason"`
}

// DeduplicateTasks uses AI to identify and remove duplicate tasks
func (d *TaskDeduplicator) DeduplicateTasks(tasks []storage.Task) ([]storage.Task, error) <span class="cov8" title="1">{
        if !d.config.AISettings.DeduplicationEnabled </span><span class="cov0" title="0">{
                return tasks, nil
        }</span>

        <span class="cov8" title="1">if len(tasks) &lt;= 1 </span><span class="cov0" title="0">{
                return tasks, nil
        }</span>

        // Prepare task summaries for AI
        <span class="cov8" title="1">var taskSummaries []TaskSummary
        taskMap := make(map[string]storage.Task)

        for _, task := range tasks </span><span class="cov8" title="1">{
                summary := TaskSummary{
                        ID:          task.ID,
                        Description: task.Description,
                        CommentID:   task.SourceCommentID,
                        Priority:    task.Priority,
                }
                taskSummaries = append(taskSummaries, summary)
                taskMap[task.ID] = task
        }</span>

        // Call AI to identify duplicates
        <span class="cov8" title="1">response, err := d.identifyDuplicates(taskSummaries)
        if err != nil </span><span class="cov8" title="1">{
                if d.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  AI deduplication failed, keeping all tasks: %v\n", err)
                }</span>
                <span class="cov8" title="1">return tasks, nil</span>
        }

        // Build result based on AI response
        <span class="cov0" title="0">var deduplicatedTasks []storage.Task
        processedIDs := make(map[string]bool)

        // Add all unique tasks
        for _, taskID := range response.UniqueTaskIDs </span><span class="cov0" title="0">{
                if task, exists := taskMap[taskID]; exists &amp;&amp; !processedIDs[taskID] </span><span class="cov0" title="0">{
                        deduplicatedTasks = append(deduplicatedTasks, task)
                        processedIDs[taskID] = true
                }</span>
        }

        // Add primary tasks from duplicate groups
        <span class="cov0" title="0">for _, group := range response.DuplicateGroups </span><span class="cov0" title="0">{
                if task, exists := taskMap[group.PrimaryTaskID]; exists &amp;&amp; !processedIDs[group.PrimaryTaskID] </span><span class="cov0" title="0">{
                        deduplicatedTasks = append(deduplicatedTasks, task)
                        processedIDs[group.PrimaryTaskID] = true
                }</span>

                // Log duplicate removals
                <span class="cov0" title="0">if d.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                        for _, dupID := range group.DuplicateTaskIDs </span><span class="cov0" title="0">{
                                if _, exists := taskMap[dupID]; exists </span><span class="cov0" title="0">{
                                        fmt.Printf("🔄 Removed duplicate task %s: %s\n", dupID, group.Reason)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if d.config.AISettings.VerboseMode </span><span class="cov0" title="0">{
                fmt.Printf("✨ AI deduplication: %d tasks → %d unique tasks\n", len(tasks), len(deduplicatedTasks))
                if response.Reasoning != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   Reasoning: %s\n", response.Reasoning)
                }</span>
        }

        <span class="cov0" title="0">return deduplicatedTasks, nil</span>
}

// identifyDuplicates calls AI to identify duplicate tasks
func (d *TaskDeduplicator) identifyDuplicates(tasks []TaskSummary) (*DeduplicationResponse, error) <span class="cov8" title="1">{
        prompt := fmt.Sprintf(`Analyze these tasks and identify duplicates based on their semantic meaning.

Tasks to analyze:
%s

Instructions:
1. Identify tasks that are semantically duplicate (same work, different wording)
2. Group duplicates together, selecting the most comprehensive one as primary
3. Consider tasks duplicate if they:
   - Request the same code change
   - Fix the same issue
   - Implement the same feature
   - Address the same problem (even if worded differently)
4. Do NOT consider tasks duplicate if they:
   - Target different files or components
   - Have different scopes (e.g., one is broader)
   - Address different aspects of a problem
   - Come from different review contexts that require separate attention

Respond in JSON format:
{
  "unique_task_ids": ["task_id1", "task_id2"],
  "duplicate_groups": [
    {
      "primary_task_id": "task_id3",
      "duplicate_task_ids": ["task_id4", "task_id5"],
      "reason": "All tasks request the same validation fix"
    }
  ],
  "reasoning": "Brief explanation of deduplication decisions"
}

Ensure every task ID appears exactly once in either unique_task_ids or as a primary/duplicate.`,
                d.formatTasksForPrompt(tasks))

        claudeCmd, err := FindClaudeCommand(d.config.AISettings.ClaudePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to find Claude: %w", err)
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(claudeCmd,
                "--output-format", "json",
                prompt)

        // Set environment for Claude command
        cmd.Env = append(cmd.Environ(), "TERM=dumb", "NO_COLOR=1")

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("claude command failed: %w\nOutput: %s", err, string(exitErr.Stderr))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to run claude: %w", err)</span>
        }

        // Parse JSON response
        <span class="cov0" title="0">var response DeduplicationResponse
        responseStr := strings.TrimSpace(string(output))

        if err := json.Unmarshal([]byte(responseStr), &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse AI response: %w\nResponse: %s", err, responseStr)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// formatTasksForPrompt formats tasks for the AI prompt
func (d *TaskDeduplicator) formatTasksForPrompt(tasks []TaskSummary) string <span class="cov8" title="1">{
        data, _ := json.MarshalIndent(tasks, "", "  ")
        return string(data)
}</span>

// DeduplicateWithinComment removes duplicate tasks within a single comment
func (d *TaskDeduplicator) DeduplicateWithinComment(tasks []storage.Task, commentID int64) ([]storage.Task, error) <span class="cov0" title="0">{
        // Filter tasks for this comment
        var commentTasks []storage.Task
        var otherTasks []storage.Task

        for _, task := range tasks </span><span class="cov0" title="0">{
                if task.SourceCommentID == commentID </span><span class="cov0" title="0">{
                        commentTasks = append(commentTasks, task)
                }</span> else<span class="cov0" title="0"> {
                        otherTasks = append(otherTasks, task)
                }</span>
        }

        <span class="cov0" title="0">if len(commentTasks) &lt;= 1 </span><span class="cov0" title="0">{
                return tasks, nil
        }</span>

        // Deduplicate tasks for this comment
        <span class="cov0" title="0">deduplicatedCommentTasks, err := d.DeduplicateTasks(commentTasks)
        if err != nil </span><span class="cov0" title="0">{
                return tasks, err
        }</span>

        // Combine with other tasks
        <span class="cov0" title="0">result := append(otherTasks, deduplicatedCommentTasks...)
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package ai

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
)

// FindClaudeCommand searches for Claude CLI in order of preference:
// 1. Custom path from config (claude_path)
// 2. Environment variable CLAUDE_PATH
// 3. PATH environment variable (exec.LookPath)
// 4. Common installation locations
func FindClaudeCommand(claudePath string) (string, error) <span class="cov8" title="1">{
        // 1. Check custom path in config
        if claudePath != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(claudePath); err == nil </span><span class="cov0" title="0">{
                        return claudePath, nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("custom claude path not found: %s", claudePath)</span>
        }

        // 2. Check environment variable
        <span class="cov8" title="1">if envPath := os.Getenv("CLAUDE_PATH"); envPath != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(envPath); err == nil </span><span class="cov0" title="0">{
                        return envPath, nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("CLAUDE_PATH environment variable points to non-existent file: %s", envPath)</span>
        }

        // 3. Check PATH
        <span class="cov8" title="1">if claudePath, err := exec.LookPath("claude"); err == nil </span><span class="cov0" title="0">{
                return claudePath, nil
        }</span>

        // 4. Check common installation locations
        <span class="cov8" title="1">homeDir := os.Getenv("HOME")
        commonPaths := []string{
                filepath.Join(homeDir, ".claude/local/claude"),   // Local installation
                filepath.Join(homeDir, ".local/bin/claude"),      // User local bin
                filepath.Join(homeDir, ".npm-global/bin/claude"), // npm global with custom prefix
                "/usr/local/bin/claude",                          // System-wide installation
                "/opt/claude/bin/claude",                         // Alternative system location
        }

        for _, path := range commonPaths </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return path, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("claude command not found in any search location")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package ai

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "strings"

        "reviewtask/internal/github"
)

// Stage 1: Format Validation (Mechanical)
func (tv *TaskValidator) validateFormat(tasks []TaskRequest) (*ValidationResult, error) <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                IsValid: false,
                Score:   0.0,
                Issues:  []ValidationIssue{},
        }

        // Validate each task structure
        validTasks := []TaskRequest{}
        for i, task := range tasks </span><span class="cov0" title="0">{
                taskIssues := tv.validateTaskFields(task, i)
                result.Issues = append(result.Issues, taskIssues...)

                // Only include tasks with no critical issues
                if !tv.hasCriticalIssues(taskIssues) </span><span class="cov0" title="0">{
                        validTasks = append(validTasks, task)
                }</span>
        }

        <span class="cov0" title="0">result.Tasks = validTasks
        result.Score = tv.calculateFormatScore(result.Issues, len(tasks))
        result.IsValid = len(result.Issues) == 0 || !tv.hasCriticalIssues(result.Issues)

        return result, nil</span>
}

func (tv *TaskValidator) validateTaskFields(task TaskRequest, index int) []ValidationIssue <span class="cov0" title="0">{
        var issues []ValidationIssue

        // Required field validation
        if task.Description == "" </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Type:        "missing",
                        TaskIndex:   index,
                        Field:       "description",
                        Description: "Task description is empty",
                        Severity:    "critical",
                })
        }</span>

        <span class="cov0" title="0">if task.OriginText == "" </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Type:        "missing",
                        TaskIndex:   index,
                        Field:       "origin_text",
                        Description: "Origin text is missing",
                        Severity:    "critical",
                })
        }</span>

        <span class="cov0" title="0">if task.SourceCommentID == 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Type:        "missing",
                        TaskIndex:   index,
                        Field:       "source_comment_id",
                        Description: "Source comment ID is missing",
                        Severity:    "critical",
                })
        }</span>

        // Priority validation
        <span class="cov0" title="0">if !tv.isValidPriority(task.Priority) </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Type:        "incorrect",
                        TaskIndex:   index,
                        Field:       "priority",
                        Description: fmt.Sprintf("Invalid priority '%s', must be critical|high|medium|low", task.Priority),
                        Severity:    "major",
                })
        }</span>

        // Task index validation
        <span class="cov0" title="0">if task.TaskIndex &lt; 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Type:        "incorrect",
                        TaskIndex:   index,
                        Field:       "task_index",
                        Description: "Task index must be &gt;= 0",
                        Severity:    "major",
                })
        }</span>

        <span class="cov0" title="0">return issues</span>
}

// Stage 2: Content Validation (AI-Powered)
func (tv *TaskValidator) validateContent(tasks []TaskRequest, originalReviews []github.Review) (*ValidationResult, error) <span class="cov0" title="0">{
        if len(tasks) == 0 </span><span class="cov0" title="0">{
                return &amp;ValidationResult{
                        IsValid: false,
                        Score:   0.0,
                        Issues: []ValidationIssue{{
                                Type:        "content",
                                TaskIndex:   -1,
                                Description: "No tasks generated",
                                Severity:    "critical",
                        }},
                }, nil
        }</span>

        // Create validation prompt
        <span class="cov0" title="0">prompt := tv.buildValidationPrompt(tasks, originalReviews)

        // Call Claude Code for content validation
        validationResponse, err := tv.callClaudeValidation(prompt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation call failed: %w", err)
        }</span>

        <span class="cov0" title="0">return validationResponse, nil</span>
}

func (tv *TaskValidator) buildValidationPrompt(tasks []TaskRequest, reviews []github.Review) string <span class="cov0" title="0">{
        var userLanguage string
        if tv.config.AISettings.UserLanguage != "" </span><span class="cov0" title="0">{
                userLanguage = fmt.Sprintf("User's preferred language: %s\n\n", tv.config.AISettings.UserLanguage)
        }</span>

        // Build original reviews data
        <span class="cov0" title="0">var reviewsData strings.Builder
        reviewsData.WriteString("ORIGINAL REVIEW COMMENTS:\n")
        for i, review := range reviews </span><span class="cov0" title="0">{
                reviewsData.WriteString(fmt.Sprintf("Review %d (ID: %d):\n", i+1, review.ID))
                if len(review.Comments) &gt; 0 </span><span class="cov0" title="0">{
                        for _, comment := range review.Comments </span><span class="cov0" title="0">{
                                reviewsData.WriteString(fmt.Sprintf("  Comment ID %d: %s\n", comment.ID, comment.Body))
                        }</span>
                }
                <span class="cov0" title="0">reviewsData.WriteString("\n")</span>
        }

        // Build generated tasks data
        <span class="cov0" title="0">var tasksData strings.Builder
        tasksData.WriteString("GENERATED TASKS TO VALIDATE:\n")
        for i, task := range tasks </span><span class="cov0" title="0">{
                tasksData.WriteString(fmt.Sprintf("Task %d:\n", i))
                tasksData.WriteString(fmt.Sprintf("  Description: %s\n", task.Description))
                tasksData.WriteString(fmt.Sprintf("  Origin Text: %s\n", task.OriginText))
                tasksData.WriteString(fmt.Sprintf("  Priority: %s\n", task.Priority))
                tasksData.WriteString(fmt.Sprintf("  Comment ID: %d\n", task.SourceCommentID))
                tasksData.WriteString(fmt.Sprintf("  Task Index: %d\n", task.TaskIndex))
                tasksData.WriteString("\n")
        }</span>

        <span class="cov0" title="0">prompt := fmt.Sprintf(`You are a code review expert validating AI-generated tasks from PR review comments.

%s
VALIDATION CRITERIA:
1. Each task should be actionable and specific
2. Task descriptions should be in the user's preferred language
3. Tasks should accurately reflect the original comment intent
4. No duplicate tasks should exist
5. All genuine issues from comments should be captured
6. Task priorities should match issue severity

RESPONSE FORMAT:
Return JSON in this EXACT format:
{
  "validation": true|false,
  "score": 0.85,
  "issues": [
    {
      "type": "content|missing|incorrect|duplicate",
      "task_index": 0,
      "description": "Specific issue description",
      "severity": "critical|major|minor",
      "suggestion": "How to fix this issue"
    }
  ]
}

%s
%s`, userLanguage, reviewsData.String(), tasksData.String())

        return prompt</span>
}

func (tv *TaskValidator) callClaudeValidation(prompt string) (*ValidationResult, error) <span class="cov0" title="0">{
        // Ensure claude CLI is available in PATH before execution
        if _, err := exec.LookPath("claude"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("claude CLI not found in PATH")
        }</span>

        // Check for very large prompts that might exceed system limits
        <span class="cov0" title="0">const maxPromptSize = 32 * 1024 // 32KB limit for safety
        if len(prompt) &gt; maxPromptSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("prompt size (%d bytes) exceeds maximum limit (%d bytes). Please shorten or chunk the prompt content", len(prompt), maxPromptSize)
        }</span>

        <span class="cov0" title="0">claudePath, err := tv.findClaudeCommand()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("claude command not found")
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(claudePath, "--output-format", "json")
        cmd.Stdin = strings.NewReader(prompt)
        // Ensure the command inherits the current environment including PATH
        cmd.Env = os.Environ()

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("claude validation execution failed")
        }</span>

        // Parse Claude Code CLI response wrapper
        <span class="cov0" title="0">var claudeResponse struct {
                Type    string `json:"type"`
                Subtype string `json:"subtype"`
                IsError bool   `json:"is_error"`
                Result  string `json:"result"`
        }

        if err := json.Unmarshal(output, &amp;claudeResponse); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse claude response")
        }</span>

        <span class="cov0" title="0">if claudeResponse.IsError </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("claude validation failed")
        }</span>

        // Extract JSON from result (may be wrapped in markdown code block)
        <span class="cov0" title="0">result := claudeResponse.Result
        result = strings.TrimSpace(result)
        if strings.HasPrefix(result, "```json") &amp;&amp; strings.HasSuffix(result, "```") </span><span class="cov0" title="0">{
                // Remove markdown code block wrapper
                lines := strings.Split(result, "\n")
                if len(lines) &gt;= 3 </span><span class="cov0" title="0">{
                        result = strings.Join(lines[1:len(lines)-1], "\n")
                }</span>
        } else<span class="cov0" title="0"> if strings.HasPrefix(result, "```") &amp;&amp; strings.HasSuffix(result, "```") </span><span class="cov0" title="0">{
                // Remove generic code block wrapper
                lines := strings.Split(result, "\n")
                if len(lines) &gt;= 3 </span><span class="cov0" title="0">{
                        result = strings.Join(lines[1:len(lines)-1], "\n")
                }</span>
        }

        // Parse validation response
        <span class="cov0" title="0">var response struct {
                Validation bool    `json:"validation"`
                Score      float64 `json:"score"`
                Issues     []struct {
                        Type        string `json:"type"`
                        TaskIndex   int    `json:"task_index"`
                        Description string `json:"description"`
                        Severity    string `json:"severity"`
                        Suggestion  string `json:"suggestion"`
                } `json:"issues"`
        }

        if err := json.Unmarshal([]byte(result), &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse validation response")
        }</span>

        // Convert to ValidationResult
        <span class="cov0" title="0">validationResult := &amp;ValidationResult{
                IsValid: response.Validation,
                Score:   response.Score,
                Issues:  []ValidationIssue{},
        }

        for _, issue := range response.Issues </span><span class="cov0" title="0">{
                validationResult.Issues = append(validationResult.Issues, ValidationIssue{
                        Type:        issue.Type,
                        TaskIndex:   issue.TaskIndex,
                        Field:       "content",
                        Description: fmt.Sprintf("%s (Suggestion: %s)", issue.Description, issue.Suggestion),
                        Severity:    issue.Severity,
                })
        }</span>

        <span class="cov0" title="0">return validationResult, nil</span>
}

// Helper functions for validation system
func (tv *TaskValidator) hasCriticalIssues(issues []ValidationIssue) bool <span class="cov0" title="0">{
        for _, issue := range issues </span><span class="cov0" title="0">{
                if issue.Severity == "critical" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (tv *TaskValidator) calculateFormatScore(issues []ValidationIssue, totalTasks int) float64 <span class="cov0" title="0">{
        if totalTasks == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">score := 1.0
        for _, issue := range issues </span><span class="cov0" title="0">{
                switch issue.Severity </span>{
                case "critical":<span class="cov0" title="0">
                        score -= 0.3</span>
                case "major":<span class="cov0" title="0">
                        score -= 0.2</span>
                case "minor":<span class="cov0" title="0">
                        score -= 0.1</span>
                }
        }

        <span class="cov0" title="0">if score &lt; 0 </span><span class="cov0" title="0">{
                score = 0
        }</span>

        <span class="cov0" title="0">return score</span>
}

func (tv *TaskValidator) isValidPriority(priority string) bool <span class="cov0" title="0">{
        validPriorities := []string{"critical", "high", "medium", "low"}
        for _, valid := range validPriorities </span><span class="cov0" title="0">{
                if priority == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// findClaudeCommand searches for Claude CLI using the shared utility function
func (tv *TaskValidator) findClaudeCommand() (string, error) <span class="cov0" title="0">{
        return FindClaudeCommand(tv.config.AISettings.ClaudePath)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
